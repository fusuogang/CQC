<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>静觅</title>
	<atom:link href="http://blog.cuiqingcai.com/feed" rel="self" type="application/rss+xml" />
	<link>http://blog.cuiqingcai.com</link>
	<description>静静寻觅生活的美好</description>
	<lastBuildDate>Fri, 13 Nov 2015 08:59:27 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=4.2.5</generator>
	<item>
		<title>WordPress从Apache迁移到Nginx过程</title>
		<link>http://blog.cuiqingcai.com/2227.html</link>
		<comments>http://blog.cuiqingcai.com/2227.html#comments</comments>
		<pubDate>Fri, 13 Nov 2015 08:59:27 +0000</pubDate>
		<dc:creator><![CDATA[崔庆才]]></dc:creator>
				<category><![CDATA[Linux]]></category>
		<category><![CDATA[PHP]]></category>
		<category><![CDATA[WordPress]]></category>

		<guid isPermaLink="false">http://blog.cuiqingcai.com/?p=2227</guid>
		<description><![CDATA[之前一直都用Apache服务器，由于网站访问量比较大，另外加上旧服务器快到期了，准备迁移到新的服务器上，所以决 [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>之前一直都用Apache服务器，由于网站访问量比较大，另外加上旧服务器快到期了，准备迁移到新的服务器上，所以决定采用Nginx服务器。</p>
<p>迁移过程比较心酸，之前一直用apache，对nginx服务器配置不熟悉，踩了很多坑。下面说一下我的网站从旧主机（配有apache服务器）迁移到新主机（配有nginx服务器）的过程。</p>
<h2>代码迁移</h2>
<p>这个过程其实也是比较心酸的，查看了一下目录结构占用空间已经足足快1个G了，可想而知里面占用的大部分空间是上传的图片素材。</p>
<p>不过要是迁移全部图片的话工程量实在是巨大。不过，好消息是我从开始就使用了七牛CDN加速，所以，上传的图片会自动存放到七牛，只不过也在主机本地留了备份而已，所以，我可以安心地删掉它们了。</p>
<p>那么对代码进行瘦身之后，这里就有两种方法来迁移了：</p>
<p>1.可以用git上传到github，然后用另一台主机把代码拉下来即可，在此不再赘述。</p>
<p>2.打包上传，然后直接在另一台主机上下载下来，由于我的两台主机在同一局域网内，所以我直接采用了这种方式，传输速度快。</p>
<h3>打包</h3>
<p>由于代码中含有 .git 目录，所以这部分我们不需要打包，那么压缩时我们就需要排除这个文件夹。</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/11/20151113155701-e1447401563242.png"><img class="alignnone size-full wp-image-2230" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/11/20151113155701-e1447401563242.png" alt="20151113155701" width="512" height="104" /></a></p>
<p>文件夹名叫cqc，那么我们就打包一下，排除.git目录，使用如下命令</p><pre class="crayon-plain-tag">tar -zcvf cqc.tar.gz --exclude=cqc/.git cqc</pre><p>运行结束后会出现 cqc.tar.gz 文件，这就是目录压缩包。</p>
<p>然后我们只需要在另一台主机上输入</p><pre class="crayon-plain-tag">wget http://xxx.xxx.xxx.xxx/cqc.tar.gz</pre><p>即可完成下载，速度可是嗖嗖的</p>
<p>然后解压即可，代码便完成了迁移。</p>
<h2>数据库迁移</h2>
<p>数据库用二者的phpmyadmin导出和上传即可。我导出 .sql 文件，大小为9M，而phpMyAdmin的上传限制大小是2M，怎么办？其实我们可以压缩 .sql 文件为 zip格式，压缩之后就有了1.4M了，分分钟完成上传。要知道 phpMyAdmin 可是支持 .sql.zip 文件的。</p>
<p>接下来是一个比较重要的部分，那就是配置一下站点信息。直接修改数据库的两个URL。</p>
<p>分别是 siteurl 和 home，一定要修改为 http://xxx.xxx.xxx.xxx/cqc 的形式，也就是把原来的域名改成IP加目录的形式，要不然网站是无法访问的，会出现多重循环定向的提示。</p>
<p>好，其他的没什么问题，连接数据库错误的话就修改一下目录的 wp-config.php 文件吧，连接数据库的信息修改正确就好了。</p>
<h2>配置vhosts</h2>
<p>和 apache 一样，我们多个域名肯定要可以解析到不同的目录吧，nginx 当然也是支持的。</p>
<p>接下来我们需要把新域名解析到 cqc 目录，在 nginx 下怎么做呢？其实还是比较简单的。</p>
<p>在 /etc/nginx 目录下可以新建一个 vhosts文件夹。在这里我们要解析 cqc 目录，那么我就新建一个 cqc.conf 文件。</p>
<p>现在例如我要把 blog.cuiqingcai.com 解析到 cqc 文件夹，配置如下</p><pre class="crayon-plain-tag">server {
	listen 80;
	server_name cuiqingcai.com blog.cuiqingcai.com;
	
	index index.html index.htm index.php;
	root /var/www/cqc;
	
	location / {
		
		if (!-e $request_filename) {
			rewrite ^([_0-9a-zA-Z-]+)?(/wp-.*) $2 last;
			rewrite ^([_0-9a-zA-Z-]+)?(/.*\.php)$ $2 last;
			rewrite ^ /index.php last;
		}
	}
	
	location ~ \.php$ {
		fastcgi_pass 127.0.0.1:9000;
	#	# With php5-fpm:
	#	fastcgi_pass unix:/var/run/php5-fpm.sock;
		fastcgi_index index.php;
		fastcgi_param SCRIPT_FILENAME /var/www/cqc$fastcgi_script_name;
		include fastcgi_params;
	}
}</pre><p>其中</p><pre class="crayon-plain-tag">location / {
		
		if (!-e $request_filename) {
			rewrite ^([_0-9a-zA-Z-]+)?(/wp-.*) $2 last;
			rewrite ^([_0-9a-zA-Z-]+)?(/.*\.php)$ $2 last;
			rewrite ^ /index.php last;
		}
	}</pre><p>这一部分是伪静态重写，因为我的博客用的是wordpress，所以伪静态重写是这样的。当然还有其他的重写方式可以尝试。</p>
<p>之后在 /etc/nginx/nginx.conf 中的 http{} 中添加一行</p><pre class="crayon-plain-tag">include /etc/nginx/vhosts/cqc.conf;</pre><p>则代表引用了这个文件。</p>
<p>注意，还要把 域名设置一下，添加一条A记录到主机上。</p>
<p>好了，一切大功告成了。</p>
<h2>后记</h2>
<p>迁移和配置的过程坑实在是太多了，列列吧，警醒世人呐。</p>
<p>（1）代码迁移过程上传git，整个项目差不多1个G，由于数据量太大，导致内存不够无法正常上传。后来删除了图片，发现项目还是很大，结果发现是 .git 目录已经占用了上百兆，后来打包排除这个目录迁移的。</p>
<p>（2）数据库迁移的时候由于phpMyAdmin上传大小限制，修改了一番上传大小结果发现没生效，还倒腾了一下php-fpm，后来发现可以直接上传压缩包，那就分分钟完成了。</p>
<p>（3）配置完之后发现网站首页正常访问了，可是其他页面全部出现了404错误，后来配置了一番伪静态解析发现配置代码直接写在了 localhost server里面，后来发现可以直接新写一个 server，然后配置域名servername，然后配置伪静态重写才成功。</p>
<p>总之，坎坷是多，但是，自己慢慢摸索出来，也是一种不错的体验。</p>
<p>当你成功之后，会觉得世界又是那么美好。</p>
<p>转载请注明：<a href="http://blog.cuiqingcai.com">静觅</a> &raquo; <a href="http://blog.cuiqingcai.com/2227.html">WordPress从Apache迁移到Nginx过程</a></p>]]></content:encoded>
			<wfw:commentRss>http://blog.cuiqingcai.com/2227.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Android开发之2048安卓版</title>
		<link>http://blog.cuiqingcai.com/2200.html</link>
		<comments>http://blog.cuiqingcai.com/2200.html#comments</comments>
		<pubDate>Sat, 07 Nov 2015 07:06:58 +0000</pubDate>
		<dc:creator><![CDATA[大龄锅]]></dc:creator>
				<category><![CDATA[Java]]></category>
		<category><![CDATA[技术杂谈]]></category>

		<guid isPermaLink="false">http://cuiqingcai.com/?p=2200</guid>
		<description><![CDATA[之前是在eclipse上写的，后面换成了android sudio。 2048游戏的UI整体可以采用线性布局， [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>之前是在eclipse上写的，后面换成了android sudio。</p>
<p>2048游戏的UI整体可以采用线性布局，即LinearLayout，其中嵌套一个线性布局和一个GridLayout，内嵌的线性布局填充文本框，以显示分数，GridLayout中填充4&#215;4的继承自FrameLayout的card类作为主要的游戏界面。由于大部分操作都在GridLayout中进行，可以自定义一个继承自GridLayout的类GameView，类中定义判定上下左右滑动的方法和每次滑动后自动添加一个随机数字的方法以及每次滑动后判断游戏是否可以继续进行的方法。</p>
<p>主布局activity_main.xml代码如下</p><pre class="crayon-plain-tag">&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/container"
	//match_parent表示布局充满整个屏幕
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context="com.example.administractor.game2048.MainActivity"
	//里面的组件垂直放置
    android:orientation="vertical"
    tools:ignore="MergeRootFrame"&gt;

    &lt;LinearLayout
	//宽度充满整个屏幕，高度自适应。
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal" &gt;
		//显示当前分数的文本框
        &lt;TextView android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Your Score:"/&gt;
        &lt;TextView
            android:id="@+id/tvScore"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"/&gt;
    &lt;/LinearLayout&gt;
	//使用自定义的GridLayout
    &lt;com.example.administractor.game2048.GameView
        android:layout_width="fill_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:id="@+id/GameView" &gt;
    &lt;/com.example.administractor.game2048.GameView&gt;
&lt;/LinearLayout&gt;</pre><p>GameView.java：</p><pre class="crayon-plain-tag">package com.example.administrator.game2048;

import java.util.ArrayList;
import java.util.List;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.graphics.Point;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.View;
import android.widget.GridLayout;

public class GameView extends GridLayout {
//调用类构造方法
    public GameView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        //初始化游戏
		InitGameView();
    }

    public GameView(Context context, AttributeSet attrs) {
        super(context, attrs);
        InitGameView();
    }

    public GameView(Context context) {
        super(context);
        InitGameView();
    }
    private void InitGameView(){
		//设置为4x4个方格
        setColumnCount(4);
		//设置背景颜色
        setBackgroundColor(0xffeee4da);

		//判定滑动方向
        setOnTouchListener(new OnTouchListener() {
            private float startx,starty,offsetx,offsety;
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                switch(event.getAction()){
                    case MotionEvent.ACTION_DOWN:
                        startx=event.getX();
                        starty=event.getY();
                        break;
                    case MotionEvent.ACTION_UP:
                        offsetx=event.getX()-startx;
                        offsety=event.getY()-starty;
                        if(Math.abs(offsetx)&gt;Math.abs(offsety)){
                            if(offsetx&lt;-5){
                                swipeLeft();
                            }else if(offsetx&gt;5){
                                swipeRight();
                            }
                        }else{
                            if(offsety&lt;-5){
                                swipeUp();
                            }else if(offsetx&gt;3){
                                swipeDown();
                            }
                        }
                        break;
                }
                return true;
            }
        });
    }
	//适应不同大小的屏幕
    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);
        int cardWidth=(Math.min(h, w))/4;
        addCards(cardWidth,cardWidth);
        startGame();
    }
	//在4x4的方格上添加满卡片
    public void addCards(int cardwidth,int cardheight){
        Card c;
        for (int y = 0; y &lt; 4; y++) {
            for (int x = 0; x &lt; 4; x++) {
                c=new Card(getContext());
                c.setNum(0);
                addView(c, cardwidth, cardheight);
                cardmap[x][y]=c;
            }
        }
    }
	//游戏开始时每个卡片默认值设为0，并随机添加两张带数字的卡片
    private void startGame(){
        MainActivity.getMainActivity().clearScore();
        for (int y = 0; y &lt; 4; y++) {
            for (int x = 0; x &lt; 4; x++) {
                cardmap[x][y].setNum(0);
            }
        }
        addRandomNum();
        addRandomNum();
    }
    private void addRandomNum() {
		//使用emptypoints将数字为0的card提取出来，并随即选择一个空card赋值
        emptyPoints.clear();
        for (int y = 0; y &lt; 4; y++) {
            for (int x = 0; x &lt; 4; x++) {
                if(cardmap[x][y].getNum()&lt;=0){
                    emptyPoints.add(new Point(x,y));
                }
            }
        }
        Point p=emptyPoints.remove((int)(Math.random()*emptyPoints.size()));
		//2和4出现的概率控制在1：9
        cardmap[p.x][p.y].setNum(Math.random()&gt;0.1?2:4);
    }
	//左滑方法
    private void swipeLeft(){
		//merge作为判断能否滑动的flag
        boolean merge = false;
        for (int y = 0; y &lt; 4; y++) {
            for (int x = 0; x &lt; 4; x++) {
                for (int x1 = x+1; x1 &lt;4; x1++) {
                    if(cardmap[x1][y].getNum()&gt;0){
                        if(cardmap[x][y].getNum()&lt;=0){
                            cardmap[x][y].setNum(cardmap[x1][y].getNum());
                            cardmap[x1][y].setNum(0);
                            merge=true;
                            x--;
                        }else if(cardmap[x][y].equal(cardmap[x1][y])){
                            cardmap[x][y].setNum(cardmap[x][y].getNum()*2);
                            cardmap[x1][y].setNum(0);
                            MainActivity.getMainActivity().addScore(cardmap[x][y].getNum());
                            merge=true;
                        }
                        break;
                    }
                }
            }
        }
        if(merge){
            addRandomNum();
            checkComplete();
        }
    }
	//下滑
    private void swipeDown(){

        boolean merge = false;

        for (int x = 0; x &lt; 4; x++) {
            for (int y = 3; y &gt;=0; y--) {

                for (int y1 = y-1; y1 &gt;=0; y1--) {
                    if (cardmap[x][y1].getNum()&gt;0) {

                        if (cardmap[x][y].getNum()&lt;=0) {
                            cardmap[x][y].setNum(cardmap[x][y1].getNum());
                            cardmap[x][y1].setNum(0);

                            y++;
                            merge = true;
                        }else if (cardmap[x][y].equal(cardmap[x][y1])) {
                            cardmap[x][y].setNum(cardmap[x][y].getNum()*2);
                            cardmap[x][y1].setNum(0);
                            MainActivity.getMainActivity().addScore(cardmap[x][y].getNum());
                            merge = true;
                        }

                        break;
                    }
                }
            }
        }

        if (merge) {
            addRandomNum();
            checkComplete();
        }
    }
	//上滑
    private void swipeUp(){

        boolean merge = false;

        for (int x = 0; x &lt; 4; x++) {
            for (int y = 0; y &lt; 4; y++) {

                for (int y1 = y+1; y1 &lt; 4; y1++) {
                    if (cardmap[x][y1].getNum()&gt;0) {

                        if (cardmap[x][y].getNum()&lt;=0) {
                            cardmap[x][y].setNum(cardmap[x][y1].getNum());
                            cardmap[x][y1].setNum(0);

                            y--;

                            merge = true;
                        }else if (cardmap[x][y].equal(cardmap[x][y1])) {
                            cardmap[x][y].setNum(cardmap[x][y].getNum()*2);
                            cardmap[x][y1].setNum(0);
                            MainActivity.getMainActivity().addScore(cardmap[x][y].getNum());
                            merge = true;
                        }

                        break;

                    }
                }
            }
        }

        if (merge) {
            addRandomNum();
            checkComplete();
        }
    }
	//右滑
    private void swipeRight(){
        boolean merge = false;
        for (int y = 0; y &lt; 4; y++) {
            for (int x = 3; x &gt;=0; x--) {
                for (int x1 = x-1; x1 &gt;=0; x1--) {
                    if(cardmap[x1][y].getNum()&gt;0){
                        if(cardmap[x][y].getNum()&lt;=0){
                            cardmap[x][y].setNum(cardmap[x1][y].getNum());
                            cardmap[x1][y].setNum(0);
                            x++;
                            merge=true;
                        }else if(cardmap[x][y].equal(cardmap[x1][y])){
                            cardmap[x][y].setNum(cardmap[x][y].getNum()*2);
                            cardmap[x1][y].setNum(0);
                            MainActivity.getMainActivity().addScore(cardmap[x][y].getNum());
                            merge=true;
                        }
                        break;
                    }
                }
            }
        }
        if(merge){
            addRandomNum();
            checkComplete();
        }
    }
	//如果有空卡片或者相邻的值相同卡片则游戏还能进行
    public void checkComplete(){
        boolean complete=true;
        ALL:
        for (int y = 0; y &lt;4; y++) {
            for (int x = 0; x &lt;4; x++) {
                if(cardmap[x][y].getNum()==0||
                        x&gt;0&amp;&amp;cardmap[x][y].equal(cardmap[x-1][y])||
                        x&lt;3&amp;&amp;cardmap[x][y].equal(cardmap[x+1][y])||
                        y&gt;0&amp;&amp;cardmap[x][y].equal(cardmap[x][y-1])||
                        y&lt;3&amp;&amp;cardmap[x][y].equal(cardmap[x][y+1])){
                    complete=false;
                    break ALL;
                }
            }
        }
		//游戏结束弹出alert提示窗口
        if(complete){
            new AlertDialog.Builder(getContext()).setTitle("大林哥温馨提示").setMessage("游戏结束").setPositiveButton("重来",new DialogInterface.OnClickListener() {

                @Override
                public void onClick(DialogInterface arg0, int arg1) {
                    startGame();
                }
            }).show();
        }

    }
    private Card[][] cardmap=new Card[4][4];
    private List&lt;Point&gt; emptyPoints=new ArrayList&lt;Point&gt;();
}</pre><p>主类MainActivity.java：</p><pre class="crayon-plain-tag">package com.example.administrator.game2048;

import android.app.Activity;
import android.os.Bundle;
import android.widget.TextView;

public class MainActivity extends Activity {

    public MainActivity(){
        mainActivity=this;
    }
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        tvscore = (TextView) findViewById(R.id.tvScore);
    }
    public void clearScore(){
        score=0;
        showScore();
    }
    public void showScore(){
        tvscore.setText(score+"");
    }
    public void addScore(int s){
        score+=s;
        showScore();
    }
    private TextView tvscore;
    private int score=0;
    public static MainActivity mainActivity=null;
    public static MainActivity getMainActivity() {
        return mainActivity;
    }
}</pre><p>Card.java：</p><pre class="crayon-plain-tag">package com.example.administrator.game2048;

import android.content.Context;
import android.view.Gravity;
import android.view.View;
import android.widget.FrameLayout;
import android.widget.TextView;

public class Card extends FrameLayout {

    public Card(Context context) {
        super(context);
        LayoutParams lp = null;

        View background = new View(getContext());
		//参数-1表示layoutparams填充满整个父容器
        lp = new LayoutParams(-1, -1);
		//设置卡片之间有10像素的间隔
        lp.setMargins(10, 10, 0, 0);
        background.setBackgroundColor(0x33ffffff);
        addView(background, lp);

        label = new TextView(getContext());
        label.setTextSize(28);
        label.setGravity(Gravity.CENTER);

        lp = new LayoutParams(-1, -1);
        lp.setMargins(10, 10, 0, 0);
        addView(label, lp);

        setNum(0);
    }



    private int n=0;
    public int getNum(){
        return n;
    }
	//设置数字及对应的背景颜色
    public void setNum(int n){
        this.n=n;
        if(n&lt;=0){
            label.setText("");
        }else{
            label.setText(n+"");
        }
        switch (n) {
            case 0:
                label.setBackgroundColor(0x00000000);
                break;
            case 2:
                label.setBackgroundColor(0xffeee4da);
                break;
            case 4:
                label.setBackgroundColor(0xffede0c8);
                break;
            case 8:
                label.setBackgroundColor(0xfff2b179);
                break;
            case 16:
                label.setBackgroundColor(0xfff59563);
                break;
            case 32:
                label.setBackgroundColor(0xfff67c5f);
                break;
            case 64:
                label.setBackgroundColor(0xfff65e3b);
                break;
            case 128:
                label.setBackgroundColor(0xffedcf72);
                break;
            case 256:
                label.setBackgroundColor(0xffedcc61);
                break;
            case 512:
                label.setBackgroundColor(0xffedc850);
                break;
            case 1024:
                label.setBackgroundColor(0xffedc53f);
                break;
            case 2048:
                label.setBackgroundColor(0xffedc22e);
                break;
            default:
                label.setBackgroundColor(0xff3c3a32);
                break;
        }
    }
	//判断卡片是否相等
    public boolean equal(Card o){
        return getNum()==o.getNum();
    }
    private TextView label;
}</pre><p>&nbsp;<br />
<img src="http://img.blog.csdn.net/20151031225217834?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /></p>
<p><img src="http://img.blog.csdn.net/20151031225316437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /></p>
<p>转载请注明：<a href="http://blog.cuiqingcai.com">静觅</a> &raquo; <a href="http://blog.cuiqingcai.com/2200.html">Android开发之2048安卓版</a></p>]]></content:encoded>
			<wfw:commentRss>http://blog.cuiqingcai.com/2200.html/feed</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>计算机网络探究三之搭建并连接VPN服务器</title>
		<link>http://blog.cuiqingcai.com/2188.html</link>
		<comments>http://blog.cuiqingcai.com/2188.html#comments</comments>
		<pubDate>Fri, 30 Oct 2015 07:33:28 +0000</pubDate>
		<dc:creator><![CDATA[崔庆才]]></dc:creator>
				<category><![CDATA[Net]]></category>
		<category><![CDATA[技术杂谈]]></category>

		<guid isPermaLink="false">http://cuiqingcai.com/?p=2188</guid>
		<description><![CDATA[openvpn原理 VPN直译就是虚拟专用通道，是提供给企业之间或者个人与公司之间安全数据传输的隧道，Open [&#8230;]]]></description>
				<content:encoded><![CDATA[<h2>openvpn原理</h2>
<p>VPN直译就是虚拟专用通道，是提供给企业之间或者个人与公司之间安全数据传输的隧道，OpenVPN无疑是Linux下开源VPN的先锋，提供了良好的性能和友好的用户GUI。</p>
<p>它大量使用了OpenSSL加密库中的SSLv3/TLSv1协议函数库。</p>
<p>目前OpenVPN能在Solaris、Linux、OpenBSD、FreeBSD、NetBSD、Mac OS X与Microsoft Windows以及Android和iOS上运行，并包含了许多安全性的功能。它并不是一个基于Web的VPN软件，也不与IPsec及其他VPN软件包兼容。</p>
<p>openvpn通过使用公开密钥（非对称密钥，加密解密使用不同的key，一个称为Publice key，另外一个是Private key）对数据进行加密的。这种方式称为TLS加密。</p>
<p>openvpn使用TLS加密的工作过程是，首先VPN Sevrver端和VPN Client端要有相同的CA证书，双方通过交换证书验证双方的合法性，用于决定是否建立VPN连接。</p>
<p>然后使用对方的CA证书，把自己目前使用的数据加密方法加密后发送给对方，由于使用的是对方CA证书加密，所以只有对方CA证书对应的Private key才能解密该数据，这样就保证了此密钥的安全性，并且此密钥是定期改变的，对于窃听者来说，可能还没有破解出此密钥，VPN通信双方可能就已经更换密钥了。</p>
<p>扩展阅读：</p>
<p><a class="dl link" href="http://baike.baidu.com/link?url=ssl8SkkfVHTcjm9UCzJ8AsJOhIHMYcxuIisO4pqyqaZF6llwP1r0fgLvYEmAg_zYhFWauFzfEyXmEmFcaprG2K">openvpn</a></p>
<h2>安装openvpn</h2>
<p>首先，你需要有一台长期运行的服务器，大家可以用自己的闲置的电脑或者买一台阿里云啦。</p>
<p>我的服务器是Ubuntu 14.04，下面就演示一下我的配置过程。</p>
<p>安装</p><pre class="crayon-plain-tag">sudo apt-get -y install openvpn libssl-dev openssl</pre><p>查看下版本并记录下来</p><pre class="crayon-plain-tag">openvpn --version</pre><p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151030145358.jpg"><img class="alignnone size-full wp-image-2189" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151030145358.jpg" alt="20151030145358" width="638" height="217" /></a></p>
<p>在这里我们的版本是2.3.2</p>
<h2>安装easy-rsa</h2>
<p>easy-rsa是用来制作openvpn相关证书的，使用如下命令安装</p><pre class="crayon-plain-tag">sudo apt-get -y install easy-rsa</pre><p>好，一切准备就绪后，我们就开始制作证书啦，我们需要制作的有三个证书</p>
<p>CA证书、Server端证书、Client端证书。行动起来。</p>
<h2>制作CA证书</h2>
<p>openvpn与easy-rsa安装完毕后，我们需要在/etc/openvpn/目录下创建easy-rsa文件夹，如下</p><pre class="crayon-plain-tag">sudo mkdir /etc/openvpn/easy-rsa/</pre><p>然后把/usr/share/easy-rsa/目录下的所有文件全部复制到/etc/openvpn/easy-rsa/下</p><pre class="crayon-plain-tag">sudo cp -r /usr/share/easy-rsa/* /etc/openvpn/easy-rsa/</pre><p>当然，我们也可以直接在/usr/share/easy-rsa/制作相关的证书，但是为了后续的管理证书的方便，我们还是把easy-rsa放在了openvpn的启动目录下。</p>
<p><strong>注意：由于我们现在使用的是ubuntu系统，所以我们必须切换到root用户下才能制作相关证书，否则easy-rsa会报错。如果是centos系统，则不存在此问题。</strong></p>
<p>切换到root用户下，使用如下命令：</p><pre class="crayon-plain-tag">sudo su</pre><p>在开始制作CA证书之前，我们还需要编辑vars文件，修改如下相关选项内容即可</p><pre class="crayon-plain-tag">sudo vi /etc/openvpn/easy-rsa/vars</pre><p></p><pre class="crayon-plain-tag">export KEY_COUNTRY="CN"
export KEY_PROVINCE="SD"
export KEY_CITY="JiNan"
export KEY_ORG="germy"
export KEY_EMAIL="cqc@cuiqingcai.com"
export KEY_OU="germy"
export KEY_NAME="germy"</pre><p>如图所示</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151030150125.jpg"><img class="alignnone size-full wp-image-2190" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151030150125.jpg" alt="20151030150125" width="432" height="206" /></a></p>
<p>之后，我们需要利用这个文件来制作我们的证书，保存一下。</p>
<p>然后一个很重要的一步，赋予权限，否则在制作证书的时候，值还是初始化的值。</p><pre class="crayon-plain-tag">sudo chmod 777 /etc/openvpn/easy-rsa/vars</pre><p>vars文件主要用于设置证书的相关组织信息，红色部分的内容可以根据自己的实际情况自行修改。</p>
<p>其中export KEY_NAME=&#8221;germy&#8221; 这个要记住下，我们下面在制作Server端证书时，会使用到。</p>
<p><strong>注意：以上内容，我们也可以使用系统默认的，也就是说不进行修改也是可以使用的。</strong></p>
<p>然后使用source vars命令使其生效，如下：</p><pre class="crayon-plain-tag">source vars
./clean-all</pre><p>注意：执行clean-all命令会删除，当前目录下的keys文件夹。</p>
<p>现在开始正式制作CA证书，使用如下命令：</p><pre class="crayon-plain-tag">cd /etc/openvpn/easy-rsa/
./build-ca</pre><p>一路回车即可。</p>
<p>制作完成后，我们可以查看keys目录里有什么东西。</p>
<p>如果你的目录下出现了ca.crt和ca.key两个文件，其中ca.crt就是我们所说的CA证书。如此，CA证书制作完毕。</p>
<p>现在把该CA证书的ca.crt文件复制到openvpn的启动目录/etc/openvpn下，如下：</p><pre class="crayon-plain-tag">cp keys/ca.crt /etc/openvpn/</pre><p></p>
<h2>制作Server端证书</h2>
<p>CA证书制作完成后，我们现在开始制作Server端证书。如下：</p><pre class="crayon-plain-tag">./build-key-server germy</pre><p>上述命令中germy，就是我们前面vars文件中设置的KEY_NAME</p>
<p>查看 keys 目录</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151030150704.jpg"><img class="alignnone size-full wp-image-2191" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151030150704.jpg" alt="20151030150704" width="569" height="339" /></a></p>
<p>如果可以发现出现了 germy.crt，germy.csr，germy.key 文件，就说明成功了。</p>
<p>现在再为服务器生成加密交换时的Diffie-Hellman文件，如下：</p><pre class="crayon-plain-tag">./build-dh</pre><p>你会发现目录下多了一个 dh2048.pem 文件。</p>
<p>以上操作完毕后，把germy.crt，germy.key，dh2048.pem 复制到 /etc/openvpn/ 目录下，如下：</p><pre class="crayon-plain-tag">cd /etc/openvpn/easy-rsa/
cp keys/germy.crt keys/germy.key keys/dh2048.pem /etc/openvpn/</pre><p>如此，Server端证书就制作完毕。</p>
<h2>制作Client端证书</h2>
<p>Server端证书制作完成后，我们现在开始制作Client端证书，如下：</p><pre class="crayon-plain-tag">./build-key cqc</pre><p>其中上述命令的cqc就是客户端证书名称，可以自定义</p>
<p>如果发现keys目录已经生成了cqc.csr、cqc.crt和cqc.key这个三个文件。其中cqc.crt和cqc.key两个文件是我们要使用的。</p>
<p>如此，Client端证书就制作完毕。</p>
<h2>配置Server端</h2>
<p>所有证书制作完毕后，我们现在开始配置Server端。Server端的配置文件，我们可以从openvpn自带的模版中进行复制。如下：</p><pre class="crayon-plain-tag">cp /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz /etc/openvpn/
cd /etc/openvpn/</pre><p>解压server.conf.gz 文件，使用如下命令：</p><pre class="crayon-plain-tag">gzip -d server.conf.gz</pre><p>注意：上述命令的意思是解压server.conf.gz文件后，然后删除原文件。</p>
<p>现在我们来修改server.conf文件</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151030151728.jpg"><img class="alignnone size-full wp-image-2192" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151030151728.jpg" alt="20151030151728" width="579" height="257" /></a></p>
<p>一共要修改四处文件。</p>
<p>第一、修改了openvpn运行时使用的协议，由原来的UDP协议修改为TCP协议。生成环境建议使用TCP协议。<br />
第二、修改了openvpn服务器的相关证书，由原来的server.csr、server.key修改为germy.crt、germy.key。<br />
第三、修改了Diffie-Hellman文件，由原来的dh1024.pem修改为dh2048.pem。</p>
<p>配置文件修改完毕后，我们现在来启动openvpn，使用如下命令：</p><pre class="crayon-plain-tag">/etc/init.d/openvpn start</pre><p>至此，服务器端的VPN已经配置完毕了。</p>
<h2>客户端的配置</h2>
<p>服务器端配置好了，我们需要用另一台机器来连接，这里我们的客户端依然是Ubuntu 14.04</p>
<p>首先我们需要从服务器上取到刚才生成的证书文件，那么我们需要的有什么呢？</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151030152200.jpg"><img class="alignnone size-full wp-image-2193" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151030152200.jpg" alt="20151030152200" width="531" height="357" /></a></p>
<p>首先这三个，ca.crt，cqc.crt，cqc.key</p>
<p>另外是一个模板，它是</p>
<p>/usr/share/doc/openvpn/examples/sample-config-files/client.conf</p>
<p>把这四个文件下载下来，然后放到客户端里。</p>
<p>比如我们保存到客户机的 home/user 文件夹下</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151030152421.jpg"><img class="alignnone size-full wp-image-2194" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151030152421.jpg" alt="20151030152421" width="359" height="35" /></a></p>
<p>把 client.conf 文件重命名为 client.ovpn</p>
<p>然后修改下面四处</p><pre class="crayon-plain-tag">proto tcp
remote 121.42.14.158 1194
ca ca.crt
cert cqc.crt
key cqc.key</pre><p>其中 remote 就是你的服务器地址</p>
<p>配置好了之后，我们运行</p><pre class="crayon-plain-tag">sudo openvpn --config client.ovpn</pre><p>如果最后的结果是</p><pre class="crayon-plain-tag">Sequence Completed</pre><p>那就证明连接成功啦。</p>
<p>输入</p><pre class="crayon-plain-tag">ifconfig</pre><p>你会发现多了一个tun0适配器，这就是openvpn的适配器。</p>
<p>至此，openvpn的配置和连接就全部完成啦。</p>
<h2>参考来源</h2>
<p><a class="dl link" href="http://www.myhack58.com/Article/sort099/sort0102/2015/65155_4.htm">参考文献</a></p>
<p>如有问题，欢迎留言交流。</p>
<p>转载请注明：<a href="http://blog.cuiqingcai.com">静觅</a> &raquo; <a href="http://blog.cuiqingcai.com/2188.html">计算机网络探究三之搭建并连接VPN服务器</a></p>]]></content:encoded>
			<wfw:commentRss>http://blog.cuiqingcai.com/2188.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>HTML5中Device Orientation的特性</title>
		<link>http://blog.cuiqingcai.com/2185.html</link>
		<comments>http://blog.cuiqingcai.com/2185.html#comments</comments>
		<pubDate>Wed, 28 Oct 2015 11:24:09 +0000</pubDate>
		<dc:creator><![CDATA[崔庆才]]></dc:creator>
				<category><![CDATA[HTML]]></category>
		<category><![CDATA[JS]]></category>

		<guid isPermaLink="false">http://cuiqingcai.com/?p=2185</guid>
		<description><![CDATA[HTML5中包含一个帮助检测device orientation的特性，使用这个特性可以在移动设备浏览器中判断 [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>HTML5中包含一个帮助检测device orientation的特性，使用这个特性可以在移动设备浏览器中判断用户设备的旋转重力方向。</p>
<h2>基本知识</h2>
<p>Alpha, Beta, Gamma角度旋转。</p>
<p>当用户旋转手机的时候，HTML5中定义了三个轴方向的旋转，如下：</p>
<p><a class="uploadimggrp" href="http://www.gbtags.com/gb/networks/uploadimg/48ca06d6-fef5-4c18-9379-a49b6b9db3af.png" target="_blank"><img src="http://www.gbtags.com/gb/networks/uploadimgthumb/48ca06d6-fef5-4c18-9379-a49b6b9db3af.png" alt="" /></a></p>
<p>上图可以看考，分别是z，x，y轴，对应分别是：Alpha，Beta，Gamma，下面图将更清楚的展示：</p>
<p><a class="uploadimggrp" href="http://www.gbtags.com/gb/networks/uploadimg/13a73e08-da9a-47a0-be1d-9d8dea6c2f98.png" target="_blank"><img src="http://www.gbtags.com/gb/networks/uploadimgthumb/13a73e08-da9a-47a0-be1d-9d8dea6c2f98.png" alt="" /></a></p>
<p>上图是Alpha旋转，　围绕Z轴旋转（绿线旋转方向，水平）</p>
<p><img src="http://www.gbtags.com/gb/networks/uploadimgthumb/3803a433-29b7-48e8-8abe-b9c48270047c.png" alt="" /></p>
<p>&nbsp;</p>
<p>上图是Beta旋转，　围绕X轴旋转（绿线旋转方向，前后）</p>
<p><img src="http://www.gbtags.com/gb/networks/uploadimgthumb/cbb478f5-4490-48f1-af44-0b9e73844057.png" alt="" /></p>
<p>上图是Beta旋转，　围绕Y轴旋转（绿线旋转方向，左右）</p>
<h2>属性</h2>
<ul>
<li>alpha: <em>(<span class="type">float</span> 类型 )</em>以z方向为轴心的旋转角度<br />
浮点数类型，只读属性，取值范围为0到360（不等于360）。</li>
<li>beta: <em>(<span class="type">float</span> 类型 )</em>以x方向为轴心的旋转角度<br />
浮点数类型，只读属性，取值范围为-180到180（不等于180）。</li>
<li>gamma: <em>(<span class="type">float</span> 类型 )</em>以y方向为轴心的旋转角度<br />
浮点数类型，只读属性，取值范围为-180到180（不等于180）。</li>
</ul>
<h2>参考</h2>
<p><a class="dl link" href="http://www.gbtags.com/gb/share/4247.htm" target="_blank">原文链接</a></p>
<p>转载请注明：<a href="http://blog.cuiqingcai.com">静觅</a> &raquo; <a href="http://blog.cuiqingcai.com/2185.html">HTML5中Device Orientation的特性</a></p>]]></content:encoded>
			<wfw:commentRss>http://blog.cuiqingcai.com/2185.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>计算机网络探究二之利用PHP实现登录验证之后上网</title>
		<link>http://blog.cuiqingcai.com/2138.html</link>
		<comments>http://blog.cuiqingcai.com/2138.html#comments</comments>
		<pubDate>Wed, 07 Oct 2015 16:27:44 +0000</pubDate>
		<dc:creator><![CDATA[崔庆才]]></dc:creator>
				<category><![CDATA[Net]]></category>
		<category><![CDATA[技术杂谈]]></category>
		<category><![CDATA[Security]]></category>

		<guid isPermaLink="false">http://cuiqingcai.com/?p=2138</guid>
		<description><![CDATA[综述 在上一篇文章中，客户机可以借助路由机直接上网，并没有什么登录限制。接下来我们将加入上网登录验证，只有输入 [&#8230;]]]></description>
				<content:encoded><![CDATA[<h2>综述</h2>
<p>在上一篇文章中，客户机可以借助路由机直接上网，并没有什么登录限制。接下来我们将加入上网登录验证，只有输入了正确的用户名和密码才可以通过验证，然后才可以访问互联网。</p>
<p>接下来，就跟随我用PHP来实现登录验证吧。</p>
<h2>环境配置</h2>
<p>在这之前，你需要配置一下LAMP环境，也就是Apache，MySQL，PHP开发环境，依次执行如下命令即可。</p><pre class="crayon-plain-tag">sudo apt-get install apache2
sudo apt-get install php5 php5-cgi php5-mysql php5-curl php5-gd php5-idn php-pear php5-imagick php5-imap php5-mcrypt php5-memcache php5-mhash php5-ming php5-pspell php5-recode php5-snmp php5-tidy php5-xmlrpc php5-sqlite php5-xsl
sudo apt-get install mysql-server mysql-client
sudo apt-get install libapache2-mod-php5
sudo apt-get install libapache2-mod-auth-mysql
sudo apt-get install phpmyadmin
sudo ln -s /usr/share/phpmyadmin/ /var/www/html/phpmyadmin</pre><p>如果配置出现问题，请查阅相关资料。</p>
<p>apache默认的目录为 /var/www/html，我们这时访问</p>
<p><a href="http://localhost">localhost</a> 或者 <a href="http://192.168.122.4">192.168.122.4</a>，都可以出现apache的欢迎界面，就证明我们配置成功了。</p>
<h2>路由初始设置</h2>
<p>为了在登录之前限制主机的上网，我们需要利用iptables规则来对数据包的转发加以限制。同时，将网页重定向到本机的登录界面。</p>
<p>初始路由设置如下</p><pre class="crayon-plain-tag">iptables -F
iptables -t nat -F
iptables -t mangle -F
iptables -P INPUT ACCEPT
iptables -P FORWARD ACCEPT
iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
iptables -t filter -A FORWARD -s 192.168.122.0/24 -o eth0 -j REJECT
iptables -t filter -A FORWARD -s 192.168.122.0/24 -d 119.29.29.29/32 -j ACCEPT
iptables -t nat -A PREROUTING -s 192.168.122.0/24 -p tcp -j DNAT --to 192.168.122.4</pre><p>首先清除所有的iptables规则，然后设置前一篇我们说的IP伪装，这时可以客户机可以通过主机上网。</p>
<p>接下来的一条规则则禁用了来自 192.168.122.0 网段的所有IP的数据包转发，然后设置可访问DNS服务器，最后一条则设置了所有的tcp连接自动跳转到 192.168.122.4，也就是我们刚才配置的服务器。</p>
<p>可以把以上规则保存为脚本，比如叫 init.sh 来运行，也可以添加到 /etc/rc.local 中，开机自动运行。</p>
<h2>登录页面</h2>
<p>访问到192.168.122.4时，我们需要给用户呈现的当然不是刚才显示的apache欢迎页面，而是登录的输入框以及登录按钮界面。</p>
<p>所以，登录界面代码如下</p><pre class="crayon-plain-tag">&lt;!DOCTYPE html&gt;
&lt;html lang="zh-CN"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
    &lt;title&gt;Auth Login&lt;/title&gt;

    &lt;!-- Bootstrap --&gt;
    &lt;link rel="stylesheet" href="css/bootstrap.min.css"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;form id="auth" method="post"&gt;
      &lt;div class="input-group"&gt;
	&lt;span class="input-group-addon" id="basic-addon1"&gt;Username&lt;/span&gt;
	&lt;input type="text" class="form-control" placeholder="Username" aria-describedby="basic-addon1" name="username"&gt;
      &lt;/div&gt;
      &lt;div class="input-group"&gt;
	&lt;span class="input-group-addon" id="basic-addon1"&gt;Password&lt;/span&gt;
	&lt;input type="text" class="form-control" placeholder="Password" aria-describedby="basic-addon1" name="password"&gt;
      &lt;/div&gt;
      &lt;input type="button" id="login" class="btn btn-primary" value="Login"&gt;
	  &lt;input type="button" id="logout" class="btn btn-primary" value="Logout"&gt;
    &lt;/form&gt;
    &lt;!-- jQuery (necessary for Bootstrap's JavaScript plugins) --&gt;
    &lt;script src="js/jquery.min.js"&gt;&lt;/script&gt;
    &lt;!-- Include all compiled plugins (below), or include individual files as needed --&gt;
    &lt;script src="js/bootstrap.min.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
  &lt;style&gt;
    form {
      max-width:400px;
      margin:0 auto;
    }
    .input-group {
      margin-bottom:20px;
    }
  &lt;/style&gt;
  &lt;script&gt;
	$(function(){
		$("#login").on("click", function() {
			$("#auth").attr("action", "/login.php");
			$("#auth").submit();
		});
		$("#logout").on("click", function() {
			$("#auth").attr("action", "/logout.php");
			$("#auth").submit();
		});
	});
  &lt;/script&gt;
&lt;/html&gt;</pre><p>其中的js，jquery文件请大家自行引入。</p>
<p>预览一下效果</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151008151728.png"><img class="alignnone size-full wp-image-2144" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151008151728.png" alt="20151008151728" width="790" height="381" /></a></p>
<p>在这里我们设置了两个按钮，一个是登录，一个是下线。</p>
<h2>数据库查询验证</h2>
<p>接下来我们新建一个数据库，例如我新建了一个数据库叫auth，然后数据表user，里面有三个字段。分别是id，username，password，我插入了一条数据。</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151008152059.png"><img class="alignnone size-full wp-image-2145" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151008152059.png" alt="20151008152059" width="799" height="504" /></a></p>
<p>接下来我们就尝试一下登录，提交到 login.php 文件验证一下。</p><pre class="crayon-plain-tag">&lt;?php
	$mysql_server_name = "localhost";
	$mysql_username = "root";
	$mysql_password = "123456";
	$mysql_database = "auth"; 
	$username = @$_POST['username'];
	$password = @$_POST['password'];
	$ip=$_SERVER["REMOTE_ADDR"];	
	$conn=mysql_connect($mysql_server_name, $mysql_username,
                        $mysql_password);
	if ($conn) {
		$sql = "select * from user where username = '".$username."'";
		$result = mysql_fetch_array(mysql_db_query($mysql_database, $sql, $conn));
		if ($result) {
			if ($result['password'] == $password) {
				$status = -1;
				system("sudo ./bash/login.sh $ip", $status);
				if ($status == 0) {
					echo "Login Successfully";				
				} else {
					echo "Login Failed";
				}
			} else {
				echo "Wrong Password";
			}	
		} else {
			echo "Not";
		}
	} else {
		die("Could Not Connect");
	}
?&gt;</pre><p>其中，最重要的部分莫过于</p><pre class="crayon-plain-tag">system("sudo ./bash/login.sh $ip", $status);</pre><p>这一行代码了，此处便是登录验证用户名和密码之后执行的一个 Linux 脚本命令。</p>
<p>在这里我把要执行的脚本写入了login.sh文件中，传入的参数便是ip地址。</p>
<p>那么login.sh里面发生了什么事情呢，我们来看一下。</p><pre class="crayon-plain-tag">iptables -t nat -D PREROUTING -s $1/32 -j ACCEPT
iptables -t nat -D PREROUTING -s $1/32 -p tcp -j ACCEPT
iptables -t filter -D FORWARD -s $1/32 -o eth0 -j ACCEPT
iptables -t nat -I PREROUTING -s $1/32 -j ACCEPT
iptables -t nat -I PREROUTING -s $1/32 -p tcp -j ACCEPT
iptables -t filter -I FORWARD -s $1/32 -o eth0 -j ACCEPT</pre><p>$1的意思就是获取第一个参数，在这里就是IP地址，脚本主要做的事情就是放行来自这个IP地址的数据包，让其正常访问互联网。</p>
<p>保存脚本后，记得给脚本赋予权限</p><pre class="crayon-plain-tag">sudo chmod 777 login.sh</pre><p>-D的意思就是删除，因为iptables是可以添加多次相同的规则的，在添加之前删除一下，以防止多次添加。</p>
<p>在这里</p><pre class="crayon-plain-tag">sudo ./bash/login.sh $ip</pre><p>执行命令脚本前，我们加了sudo，意思就是管理员身份运行，但是仍然可能导致权限问题，因为命令的执行者是PHP（其实是www-data），而并不是root用户，所以我们需要修改一下执行权限。</p>
<p>首先通过PHP文件获取执行该命令的用户是叫什么，比如新建一个 info.php 文件，输入如下内容：</p><pre class="crayon-plain-tag">&lt;?php 
    echo shell_exec("id -a");
?&gt;</pre><p>看一下运行结果</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151008153424.png"><img class="alignnone size-full wp-image-2146" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151008153424.png" alt="20151008153424" width="796" height="247" /></a></p>
<p>嗯，果然，执行用户是www-data，这样我们只需要给www-data添加一个执行权限就好了。</p>
<p>修改 /etc/sudoers 文件</p>
<p>添加一行</p><pre class="crayon-plain-tag">www-data ALL=(ALL) NOPASSWD:ALL</pre><p>意思是www-data以root身份运行并且不需要密码。</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151008153700.png"><img class="alignnone size-full wp-image-2147" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151008153700.png" alt="20151008153700" width="802" height="534" /></a></p>
<p>好，保存之后，我们尝试一下，就可以登录啦。</p>
<h2>测试登录</h2>
<p>在路由主机（Ubuntu Route）里面，初始化一下iptables规则，然后查看当前规则。</p>
<p>我们发现当前访问都是被阻止的，而且tcp连接会自动跳转到 192.168.122.4</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151008154216.png"><img class="alignnone size-full wp-image-2149" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151008154216.png" alt="20151008154216" width="800" height="572" /></a></p>
<p>现在我们登录客户机，随机打开一个网址，比如百度，就发现自动跳转到了登录界面</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151008154629.png"><img class="alignnone size-full wp-image-2150" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151008154629.png" alt="20151008154629" width="795" height="312" /></a></p>
<p>输入用户名密码，尝试登陆，比如之前插入数据库的是cqc，123456，输入之后登录。</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151008162712.png"><img class="alignnone size-full wp-image-2152" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151008162712.png" alt="20151008162712" width="798" height="320" /></a></p>
<p>提示登录成功之后，我们便可以欢乐地上网啦。</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151008162926.png"><img class="alignnone size-full wp-image-2153" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151008162926.png" alt="20151008162926" width="798" height="547" /></a></p>
<p>好，这样我们就完成了验证之后上网啦。</p>
<h2>下线操作</h2>
<p>同样的，下线操作我们同样写一个logout.php</p><pre class="crayon-plain-tag">&lt;?php
	$mysql_server_name = "localhost";
	$mysql_username = "root";
	$mysql_password = "123456";
	$mysql_database = "auth"; 
	$username = @$_POST['username'];
	$password = @$_POST['password'];
	$ip=$_SERVER["REMOTE_ADDR"];
	echo $ip;	
	$conn=mysql_connect($mysql_server_name, $mysql_username,
                        $mysql_password);
	if ($conn) {
		$sql = "select * from user where username = '".$username."'";
		$result = mysql_fetch_array(mysql_db_query($mysql_database, $sql, $conn));
		if ($result) {
			if ($result['password'] == $password) {
				$status = -1;
				system("sudo ./bash/logout.sh $ip", $status);
				if ($status == 0) {
					echo "Login Successfully";				
				} else {
					echo "Login Failed";
				}
			} else {
				echo "Wrong Password";
			}	
		} else {
			echo "Not";
		}
	} else {
		die("Could Not Connect");
	}
?&gt;</pre><p>登出的脚本如下，其实就是单纯去除了刚才添加的路由规则</p><pre class="crayon-plain-tag">iptables -t nat -D PREROUTING -s $1/32 -j ACCEPT
iptables -t nat -D PREROUTING -s $1/32 -p tcp -j ACCEPT
iptables -t filter -D FORWARD -s $1/32 -o eth0 -j ACCEPT</pre><p>配置方式和登录一样，大家可以尝试下。</p>
<h2>源代码</h2>
<p>在这里提供大家源代码下载</p>
<p><a class="dl link" href="https://github.com/cqcre/PHPLogin">源码下载</a></p>
<p>如有问题，欢迎交流。</p>
<p>转载请注明：<a href="http://blog.cuiqingcai.com">静觅</a> &raquo; <a href="http://blog.cuiqingcai.com/2138.html">计算机网络探究二之利用PHP实现登录验证之后上网</a></p>]]></content:encoded>
			<wfw:commentRss>http://blog.cuiqingcai.com/2138.html/feed</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
		<item>
		<title>计算机网络探究一之利用双网卡主机共享上网</title>
		<link>http://blog.cuiqingcai.com/2126.html</link>
		<comments>http://blog.cuiqingcai.com/2126.html#comments</comments>
		<pubDate>Wed, 07 Oct 2015 09:23:37 +0000</pubDate>
		<dc:creator><![CDATA[崔庆才]]></dc:creator>
				<category><![CDATA[Net]]></category>
		<category><![CDATA[技术杂谈]]></category>
		<category><![CDATA[Security]]></category>

		<guid isPermaLink="false">http://cuiqingcai.com/?p=2126</guid>
		<description><![CDATA[综述 大家好，这次我们需要实现的是实现双网卡主机共享上网，就是一台主机通过连接另一台可以访问外网的双网卡主机来 [&#8230;]]]></description>
				<content:encoded><![CDATA[<h2>综述</h2>
<p>大家好，这次我们需要实现的是实现双网卡主机共享上网，就是一台主机通过连接另一台可以访问外网的双网卡主机来正常上网。所以我们需要两台机器来进行测试，在这里我们用的是两台Ubuntu 14.04，其中一台是单网卡，一台是双网卡。废话不多说，行动起来吧。</p>
<h2>配置系统</h2>
<p>博主使用了Vmware来安装了两台Ubuntu主机，一台当路由机，名称是Ubuntu Route，另一台是客户机，名称是Ubuntu Desktop，具体的网络配置如下：</p>
<p>Ubuntu Route：</p>
<p>一个网卡eth0通过NAT方式来与外部主机共享上网，这个网卡也就是VMnet8网卡，网段是192.168.231.0</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151007164043.png"><img class="alignnone size-full wp-image-2127" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151007164043.png" alt="20151007164043" width="717" height="415" /></a></p>
<p>另一个网卡eth1连接了一个自定义的仅主机模式的网卡VMnet2，网段是192.168.122.0</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151007164114.png"><img class="alignnone size-full wp-image-2128" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151007164114.png" alt="20151007164114" width="719" height="439" /></a></p>
<p>网络适配器设置如下，eth0开启了DHCP，ech1没有开启DHCP</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151007164343.png"><img class="alignnone size-full wp-image-2129" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151007164343.png" alt="20151007164343" width="604" height="538" /></a></p>
<p>Ubuntu Desktop：</p>
<p>一个网卡eth0连接刚才那个自定义的仅主机模式的网卡VMnet2，网段是192.168.122.0</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151007164821.png"><img class="alignnone size-full wp-image-2131" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151007164821.png" alt="20151007164821" width="725" height="445" /></a></p>
<p>好了，以上就是基本硬件的配置</p>
<h2>设置IP</h2>
<p>接下来我们设置一下Ubuntu Route的IP地址，修改 /etc/network/interfaces</p><pre class="crayon-plain-tag">auto lo
iface lo inet loopback
auto eth0
iface eth0 inet dhcp
auto eth1
iface eth1 inet static
address 192.168.122.4
netmask 255.255.255.0</pre><p>在这里，eth0因为我们在VMware里面设置了DHCP，所以这里我们设置dhcp即可，eth1需要手动配置一下，我们分配了 192.168.122.4 这个IP地址，当然你可以随意指定，子网掩码如上，不需要写网关，因为它本身作为一个路由。</p>
<p>可以通过执行如下命令来使之生效</p><pre class="crayon-plain-tag">sudo /etc/init.d/networking restart</pre><p>如果上述方法不行，则可以尝试使用关闭网卡和开启网卡的命令。</p><pre class="crayon-plain-tag">sudo ifup eth0
sudo ifdown eth0</pre><p>eth1的开启和关闭同上</p>
<h2>开启路由转发</h2>
<p>修改 /etc/sysctl.conf 文件，将</p><pre class="crayon-plain-tag">net.ipv4.ip_forward=1</pre><p>这一行取消注释，代表开启了路由转发功能。</p>
<p>也可以通过执行</p><pre class="crayon-plain-tag">echo 1 &gt; /proc/sys/net/ipv4/ip_forward</pre><p>命令来实现</p>
<h2>设置iptables规则</h2>
<p>iptables是非常重要的一个环节，如果大家不熟悉，可以去搜相关资料了解一下。</p>
<p>执行如下命令，来设置一下iptables规则，可以直接在命令行逐条执行，也可以写成一个脚本来执行。</p><pre class="crayon-plain-tag">iptables -F
iptables -t nat -F
iptables -t mangle -F
iptables -P INPUT ACCEPT
iptables -P FORWARD ACCEPT
iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</pre><p>其中最后一条是最重要的，代表将数据包通过eth0网卡来转发，也是IP伪装的一个常用方法，有了这条指令，从eth1网卡流经的一些数据包可以通过eth0来转发，这样就相当于连通了两个网卡，这样与eth1网卡连接的主机便可以上网了。</p>
<h2>客户主机设置</h2>
<p>因为客户机的eth0连接了VMnet2网卡，而VMnet2网卡又与路由主机的eth1连接，我们只需要简单设置一下IP地址就好了。</p>
<p>修改 /etc/network/interfaces</p><pre class="crayon-plain-tag">auto eth0
iface eth0 inet static
address 192.168.122.5
netmask 255.255.255.0
gateway 192.168.122.4
dns-nameservers 119.29.29.29</pre><p>这里很重要的一个设置就是网关，设置成路由主机的IP地址。</p>
<p>设置完了同样重启一下网卡使其生效。</p>
<p>还可以选择性设置下DNS服务器。</p>
<p>至此，所有配置都完成了，测试一下吧。</p>
<h2>测试</h2>
<p>我们在客户机里打开浏览器，输入随意一个网页测试一下。</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151007172000.png"><img class="alignnone size-full wp-image-2133" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/10/20151007172000.png" alt="20151007172000" width="988" height="662" /></a></p>
<p>嗯，客户机可以正常上网啦，一切都是那么轻松加愉快！</p>
<p>如有问题，欢迎留言交流~</p>
<p>转载请注明：<a href="http://blog.cuiqingcai.com">静觅</a> &raquo; <a href="http://blog.cuiqingcai.com/2126.html">计算机网络探究一之利用双网卡主机共享上网</a></p>]]></content:encoded>
			<wfw:commentRss>http://blog.cuiqingcai.com/2126.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>自己动手实现山东大学QLSC_STU无线网络掉线后自动重连</title>
		<link>http://blog.cuiqingcai.com/2083.html</link>
		<comments>http://blog.cuiqingcai.com/2083.html#comments</comments>
		<pubDate>Sun, 20 Sep 2015 13:01:06 +0000</pubDate>
		<dc:creator><![CDATA[崔庆才]]></dc:creator>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[Security]]></category>

		<guid isPermaLink="false">http://cuiqingcai.com/?p=2083</guid>
		<description><![CDATA[综述 最近山大软件园校区QLSC_STU无线网掉线掉的厉害，连上之后平均十分钟左右掉线一次，很是让人心烦，还能 [&#8230;]]]></description>
				<content:encoded><![CDATA[<h2>综述</h2>
<p>最近山大软件园校区QLSC_STU无线网掉线掉的厉害，连上之后平均十分钟左右掉线一次，很是让人心烦，还能不能愉快地上自习了？能忍吗？反正我是不能忍了，嗯，自己动手，丰衣足食！写个程序解决掉它！</p>
<h2>决战前夕</h2>
<p>首先我们看一下那个验证页面是咋样滴，上个图先</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150920192557.png"><img class="alignnone size-full wp-image-2085" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150920192557.png" alt="20150920192557" width="698" height="547" /></a></p>
<p>嘿，这界面还算可以把，需要我们输入的东西就是俩，一个就是学号，另一个是身份证号后六位，然后就可以登录，享受免费的无线网啦。</p>
<p>不过不知道谁设置了个登录时长，一段时间后就会掉线了，于是，自动模拟登陆系统就要应运而生啦。</p>
<p>来，我们先点击一下连接，看一下浏览器怎么工作的。</p>
<p>按下F12，监听网络，我们点击第一个响应，也就是login.jsp，看一下。 <a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150920192957.png"><img class="alignnone size-large wp-image-2087" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150920192957-1024x661.png" alt="20150920192957" width="1024" height="661" /></a> 我们具体看一下headers，里面form提交了什么东西，真的是茫茫多的数据啊。 <a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150920193146.png"><img class="alignnone size-full wp-image-2089" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150920193146.png" alt="20150920193146" width="422" height="488" /></a> 嗯，一目了然POST的数据和提交的地址。 让我们来分析几个数据吧：</p>
<blockquote>
<p class="">ClientIP：当前客户端的IP地址，在山大软件园校区这个地址是211.87开头的</p>
<p class="">timeoutvalue：连接等待时间，也就是俗话说的timeout</p>
<p class="">StartTime：登录时间，也就是在你登录的那一刻的时间戳，这个时间戳是13位的，精确到了毫秒，不过一般是10位的，我们加3个0就好了</p>
<p class="">shkOvertime：登录持续时间，这个数据默认是720，也就是12分钟之后，登录就失效了，自动掉线，我们可以手动更改</p>
<p class="">username：学号</p>
<p class="">password：密码，也就是我们身份证号后六位</p>
</blockquote>
<p>我们需要在登录的时候把form表单中的所有信息都POST一下，然后就可以完成登录啦。 万事俱备，只欠东风，来来来，程序写起来！</p>
<h2>一触即发</h2>
<p>说走咱就走啊，天上的星星参北斗啊！</p>
<p>登陆地址：Request URL:http://192.168.8.10/portal/login.jsp?Flag=0</p>
<p>首先，我们需要验证一下IP地址，先写一个获取IP地址的函数，首先判断当前IP是不是211.87开头的，如果是的话，证明连接的IP是有效的。 首先我们写一个获取本机IP的方法：</p><pre class="crayon-plain-tag">self.ip_pre = "211.87"    
#获取本机无线IP
    def getIP(self):
        local_iP = socket.gethostbyname(socket.gethostname())
        if self.ip_pre in str(local_iP):
            return str(local_iP)
        ip_lists = socket.gethostbyname_ex(socket.gethostname())

        for ip_list in ip_lists:
            if isinstance(ip_list, list):
                for i in ip_list:
                    if self.ip_pre in str(i):
                        return str(i)
            elif type(ip_list) is types.StringType:
                if self.ip_pre in ip_list:
                    return ip_list</pre><p>这个方法利用了gethostbyname和gethostbyname_ex方法，获取了各个网卡的IP地址，遍历一下，找到那个211.87开头的IP，返回 接下来，获取到IP之后，我们便可以构建form，然后进行模拟登陆了。</p><pre class="crayon-plain-tag">#模拟登录
    def login(self):
        print self.getCurrentTime(), u"正在尝试认证QLSC_STU无线网络"
        ip = self.getIP()
        data = {
            "username": self.username,
            "password": self.password,
            "serverType": "",
            "isSavePass": "on",
            "Submit1": "",
            "Language": "Chinese",
            "ClientIP": self.getIP(),
            "timeoutvalue": 45,
            "heartbeat": 240,
            "fastwebornot": False,
            "StartTime": self.getNowTime(),
            #持续时间，超过这个时间自动掉线，可进行设置
            "shkOvertime": self.overtime,
            "strOSName": "",
            "iAdptIndex": "",
            "strAdptName": "",
            "strAdptStdName": "",
            "strFileEncoding": "",
            "PhysAddr": "",
            "bDHCPEnabled": "",
            "strIPAddrArray": "",
            "strMaskArray": "",
            "strMask": "",
            "iDHCPDelayTime": "",
            "iDHCPTryTimes": "",
            "strOldPrivateIP": self.getIP(),
            "strOldPublicIP": self.getIP(),
            "strPrivateIP": self.getIP(),
            "PublicIP": self.getIP(),
            "iIPCONFIG":0,
            "sHttpPrefix": "http://192.168.8.10",
            "title": "CAMS Portal"
        }
        #消息头
        headers = {
            'User-Agent' : 'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.111 Safari/537.36',
            'Host': '192.168.8.10',
            'Origin': 'http://192.168.8.10',
            'Referer': 'http://192.168.8.10/portal/index_default.jsp?Language=Chinese'
        }
        post_data = urllib.urlencode(data)
        login_url = "http://192.168.8.10/portal/login.jsp?Flag=0"
        request = urllib2.Request(login_url, post_data, headers)
        response = urllib2.urlopen(request)
        result = response.read().decode('gbk')</pre><p>比较多的内容就在于form表单的数据内容以及请求头，后来利用urllib2的urlopen方法实现模拟登陆。</p>
<p>如果大家对此不熟悉，可以参见</p>
<p><a class="dl link" href="http://cuiqingcai.com/947.html">Urllib的基本使用</a></p>
<p>这样，登录后的结果就会保存在result变量中，我们只需要从result中提取出我们需要的数据就可以了。</p>
<h2>乘胜追击</h2>
<p>接下来，我们就分析一下数据啦，结果有这么几种：</p>
<blockquote><p>1.登录成功 2.已经登录 3.用户不存在 4.密码错误 5.未知错误</p></blockquote>
<p>好，利用result分析一下结果</p><pre class="crayon-plain-tag">#打印登录结果
    def getLoginResult(self, result):
        if u"用户上线成功" in result:
            print self.getCurrentTime(),u"用户上线成功,在线时长为",self.overtime/60,"分钟"
        elif u"您已经建立了连接" in result:
            print self.getCurrentTime(),u"您已经建立了连接,无需重复登陆"
        elif u"用户不存在" in result:
            print self.getCurrentTime(),u"用户不存在，请检查学号是否正确"
        elif u"用户密码错误" in result:
            pattern = re.compile('&lt;td class="tWhite"&gt;.*?2553:(.*?)&lt;/b&gt;.*?&lt;/td&gt;', re.S)
            res = re.search(pattern, result)
            if res:
                print self.getCurrentTime(),res.group(1),u"请重新修改密码"
        else:
            print self.getCurrentTime(),u"未知错误，请检查学号密码是否正确"</pre><p>通过字符串匹配和正则表达式，我们分辨并提取出了上述五种情况。</p>
<p>增加循环检测 既然是检测网络是否断开，那么我们只需要每隔一段时间检测一下就好了，那就10秒吧。</p>
<p>因为这个10秒是可配置的，为了方便配置，统一配置到__init__方法里面。</p><pre class="crayon-plain-tag">#检测间隔时间，单位为秒
self.every = 10</pre><p>然后，我们写一个循环来检测一下</p><pre class="crayon-plain-tag">while True:
            nowIP = self.getIP()
            if not nowIP:
                print self.getCurrentTime(), u"请检查是否正常连接QLSC_STU无线网络"
            else:
                print self.getCurrentTime(),u"成功连接了QLSC_STU网络,本机IP为",nowIP
                self.login()
                while True:
                    can_connect = self.canConnect()
                    if not can_connect:
                        nowIP = self.getIP()
                        if not nowIP:
                            print self.getCurrentTime(), u"当前已经断线，请确保连接上了QLSC_STU网络"
                        else:
                            print self.getCurrentTime(), u"当前已经断线，正在尝试重新连接"
                            self.login()
                    else:
                        print self.getCurrentTime(), u"当前网络连接正常"
                    time.sleep(self.every)
            time.sleep(self.every)</pre><p>其中我们用到了canConnect方法，这个就是检测网络是否已经断开的方法，我们可以利用ping百度的方法来检测一下。</p>
<p>方法实现如下</p><pre class="crayon-plain-tag">#判断当前是否可以联网
    def canConnect(self):
        fnull = open(os.devnull, 'w')
        result = subprocess.call('ping www.baidu.com', shell = True, stdout = fnull, stderr = fnull)
        fnull.close()
        if result:
            return False
        else:
            return True</pre><p>好啦，所有的要点我们已经逐一击破，等着凯旋吧</p>
<h2>收拾战场</h2>
<p>好了，所有的代码要点已经被我们攻破了，接下来就整理一下，让他们组合起来，变成一个应用程序吧。</p><pre class="crayon-plain-tag">__author__ = 'CQC'
#-*- coding:utf-8 -*-

import urllib
import urllib2
import socket
import types
import time
import re
import os
import subprocess

class Login:

    #初始化
    def __init__(self):
        #学号密码
        self.username = '201200131012'
        self.password = 'XXXXXX'
        #山大无线STU的IP网段
        self.ip_pre = '211.87'
        #登录时长
        self.overtime = 720
        #检测间隔时间，单位为秒
        self.every = 10

    #模拟登录
    def login(self):
        print self.getCurrentTime(), u"正在尝试认证QLSC_STU无线网络"
        ip = self.getIP()
        data = {
            "username": self.username,
            "password": self.password,
            "serverType": "",
            "isSavePass": "on",
            "Submit1": "",
            "Language": "Chinese",
            "ClientIP": self.getIP(),
            "timeoutvalue": 45,
            "heartbeat": 240,
            "fastwebornot": False,
            "StartTime": self.getNowTime(),
            #持续时间，超过这个时间自动掉线，可进行设置
            "shkOvertime": self.overtime,
            "strOSName": "",
            "iAdptIndex": "",
            "strAdptName": "",
            "strAdptStdName": "",
            "strFileEncoding": "",
            "PhysAddr": "",
            "bDHCPEnabled": "",
            "strIPAddrArray": "",
            "strMaskArray": "",
            "strMask": "",
            "iDHCPDelayTime": "",
            "iDHCPTryTimes": "",
            "strOldPrivateIP": self.getIP(),
            "strOldPublicIP": self.getIP(),
            "strPrivateIP": self.getIP(),
            "PublicIP": self.getIP(),
            "iIPCONFIG":0,
            "sHttpPrefix": "http://192.168.8.10",
            "title": "CAMS Portal"
        }
        #消息头
        headers = {
            'User-Agent' : 'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.111 Safari/537.36',
            'Host': '192.168.8.10',
            'Origin': 'http://192.168.8.10',
            'Referer': 'http://192.168.8.10/portal/index_default.jsp?Language=Chinese'
        }
        post_data = urllib.urlencode(data)
        login_url = "http://192.168.8.10/portal/login.jsp?Flag=0"
        request = urllib2.Request(login_url, post_data, headers)
        response = urllib2.urlopen(request)
        result = response.read().decode('gbk')
        self.getLoginResult(result)


    #打印登录结果
    def getLoginResult(self, result):
        if u"用户上线成功" in result:
            print self.getCurrentTime(),u"用户上线成功,在线时长为",self.overtime/60,"分钟"
        elif u"您已经建立了连接" in result:
            print self.getCurrentTime(),u"您已经建立了连接,无需重复登陆"
        elif u"用户不存在" in result:
            print self.getCurrentTime(),u"用户不存在，请检查学号是否正确"
        elif u"用户密码错误" in result:
            pattern = re.compile('&lt;td class="tWhite"&gt;.*?2553:(.*?)&lt;/b&gt;.*?&lt;/td&gt;', re.S)
            res = re.search(pattern, result)
            if res:
                print self.getCurrentTime(),res.group(1),u"请重新修改密码"
        else:
            print self.getCurrentTime(),u"未知错误，请检查学号密码是否正确"

    #获取当前时间戳，13位
    def getNowTime(self):
        return str(int(time.time()))+"000"

    #获取本机无线IP
    def getIP(self):
        local_iP = socket.gethostbyname(socket.gethostname())
        if self.ip_pre in str(local_iP):
            return str(local_iP)
        ip_lists = socket.gethostbyname_ex(socket.gethostname())

        for ip_list in ip_lists:
            if isinstance(ip_list, list):
                for i in ip_list:
                    if self.ip_pre in str(i):
                        return str(i)
            elif type(ip_list) is types.StringType:
                if self.ip_pre in ip_list:
                    return ip_list

    #判断当前是否可以联网
    def canConnect(self):
        fnull = open(os.devnull, 'w')
        result = subprocess.call('ping www.baidu.com', shell = True, stdout = fnull, stderr = fnull)
        fnull.close()
        if result:
            return False
        else:
            return True

    #获取当前时间
    def getCurrentTime(self):
        return time.strftime('[%Y-%m-%d %H:%M:%S]',time.localtime(time.time()))

    #主函数
    def main(self):
        print self.getCurrentTime(), u"您好，欢迎使用模拟登陆系统"
        while True:
            nowIP = self.getIP()
            if not nowIP:
                print self.getCurrentTime(), u"请检查是否正常连接QLSC_STU无线网络"
            else:
                print self.getCurrentTime(),u"成功连接了QLSC_STU网络,本机IP为",nowIP
                self.login()
                while True:
                    can_connect = self.canConnect()
                    if not can_connect:
                        nowIP = self.getIP()
                        if not nowIP:
                            print self.getCurrentTime(), u"当前已经掉线，请确保连接上了QLSC_STU网络"
                        else:
                            print self.getCurrentTime(), u"当前已经掉线，正在尝试重新连接"
                            self.login()
                    else:
                        print self.getCurrentTime(), u"当前网络连接正常"
                    time.sleep(self.every)
            time.sleep(self.every)

login = Login()
login.main()</pre><p>来，我们来运行一下，看下效果吧！ 执行</p><pre class="crayon-plain-tag">python login.py</pre><p>当前是可以联网的，我分别在网页上操作执行了断开，操作，程序自动检测到掉线，自动重新连接。</p>
<p>接下来我直接断开了QLSC_STU网络的链接，程序同样检测到QLSC_STU这个热点没有连接上，提示用户链接。</p>
<p>接下来我重新连接上了这个热点，由于刚才已经登录上线，且持续时间较短，网络自动恢复正常。</p>
<p>下面是运行结果：</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150920205618.png"><img class="alignnone size-full wp-image-2093" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150920205618.png" alt="20150920205618" width="677" height="347" /></a></p>
<p>嗯，这样我们就是实现了自动掉线的检测和模拟登录。</p>
<h2>凯旋而归</h2>
<p>咿呀伊尔哟，想约妹子上自习吗？那就赶紧来试试吧！一网在手，天下我有！追男神女神都不再是梦想！</p>
<p>如果有问题，欢迎留言讨论，代码肯定有不完善的地方，仅供参考。</p>
<p>转载请注明：<a href="http://blog.cuiqingcai.com">静觅</a> &raquo; <a href="http://blog.cuiqingcai.com/2083.html">自己动手实现山东大学QLSC_STU无线网络掉线后自动重连</a></p>]]></content:encoded>
			<wfw:commentRss>http://blog.cuiqingcai.com/2083.html/feed</wfw:commentRss>
		<slash:comments>13</slash:comments>
		</item>
		<item>
		<title>浅谈CSRF攻击方式</title>
		<link>http://blog.cuiqingcai.com/2076.html</link>
		<comments>http://blog.cuiqingcai.com/2076.html#comments</comments>
		<pubDate>Thu, 17 Sep 2015 15:08:41 +0000</pubDate>
		<dc:creator><![CDATA[崔庆才]]></dc:creator>
				<category><![CDATA[Other]]></category>
		<category><![CDATA[PHP]]></category>
		<category><![CDATA[Security]]></category>

		<guid isPermaLink="false">http://cuiqingcai.com/?p=2076</guid>
		<description><![CDATA[CSRF是什么？ CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也 [&#8230;]]]></description>
				<content:encoded><![CDATA[<h2><b>CSRF是什么？</b></h2>
<p>CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。</p>
<h2><b>CSRF可以做什么？</b></h2>
<p>你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账&#8230;&#8230;造成的问题包括：个人隐私泄露以及财产安全。</p>
<h2><b>CSRF漏洞现状</b></h2>
<p>CSRF这种攻击方式在2000年已经被国外的安全人员提出，但在国内，直到06年才开始被关注，08年，国内外的多个大型社区和交互网站分别爆出CSRF漏洞，如：NYTimes.com（纽约时报）、Metafilter（一个大型的BLOG网站），YouTube和百度HI&#8230;&#8230;而现在，互联网上的许多站点仍对此毫无防备，以至于安全业界称CSRF为“沉睡的巨人”。</p>
<h2><b>CSRF的原理</b></h2>
<p>下图简单阐述了CSRF攻击的思想：</p>
<p><img src="http://pic002.cnblogs.com/img/hyddd/200904/2009040916453171.jpg" alt="" width="884" height="498" /></p>
<p>从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p>
<blockquote><p>　　1.登录受信任网站A，并在本地生成Cookie。</p>
<p>2.在不登出A的情况下，访问危险网站B。</p></blockquote>
<p>看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生：</p>
<blockquote><p>　　1.你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。</p>
<p>2.你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了&#8230;&#8230;）</p>
<p>3.上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。</p></blockquote>
<p>上面大概地讲了一下CSRF攻击的思想，下面我将用几个例子详细说说具体的CSRF攻击，这里我以一个银行转账的操作作为例子（仅仅是例子，真实的银行网站没这么傻:&gt;）</p>
<h3><b>　　示例1：</b></h3>
<p>银行网站A，它以GET请求来完成银行转账的操作，如：http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</p>
<p>危险网站B，它里面有一段HTML的代码如下：</p><pre class="crayon-plain-tag">&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;</pre><p>首先，你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块&#8230;&#8230;</p>
<p>为什么会这样呢？原因是银行网站A违反了HTTP规范，使用GET请求更新资源。在访问危险网站B的之前，你已经登录了银行网站A，而B中的&lt;img&gt;以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏览器会带上你的银行网站A的Cookie发出Get请求，去获取资源“http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000”，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作&#8230;&#8230;</p>
<h3>　　<b>示例2：</b></h3>
<p>为了杜绝上面的问题，银行决定改用POST请求完成转账操作。</p>
<p>银行网站A的WEB表单如下：</p><pre class="crayon-plain-tag">　　&lt;form action="Transfer.php" method="POST"&gt;
　　　　&lt;p&gt;ToBankId: &lt;input type="text" name="toBankId" /&gt;&lt;/p&gt;
　　　　&lt;p&gt;Money: &lt;input type="text" name="money" /&gt;&lt;/p&gt;
　　　　&lt;p&gt;&lt;input type="submit" value="Transfer" /&gt;&lt;/p&gt;
　　&lt;/form&gt;</pre><p>后台处理页面Transfer.php如下：</p><pre class="crayon-plain-tag">　　&lt;?php
　　　　session_start();
　　　　if (isset($_REQUEST['toBankId'] &amp;&amp;　isset($_REQUEST['money']))
　　　　{
　　　　    buy_stocks($_REQUEST['toBankId'],　$_REQUEST['money']);
　　　　}
　　?&gt;</pre><p>危险网站B，仍然只是包含那句HTML代码：</p><pre class="crayon-plain-tag">&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;</pre><p>和示例1中的操作一样，你首先登录了银行网站A，然后访问危险网站B，结果&#8230;..和示例1一样，你再次没了1000块～T_T，这次事故的原因是：银行后台使用了$_REQUEST去获取请求的数据，而$_REQUEST既可以获取GET请求的数据，也可以获取POST请求的数据，这就造成了在后台处理程序无法区分这到底是GET请求的数据还是POST请求的数据。在PHP中，可以使用$_GET和$_POST分别获取GET请求和POST请求的数据。在JAVA中，用于获取请求数据request一样存在不能区分GET请求数据和POST数据的问题。</p>
<h3>　　<b>示例3：</b></h3>
<p>经过前面2个惨痛的教训，银行决定把获取请求数据的方法也改了，改用$_POST，只获取POST请求的数据，后台处理页面Transfer.php代码如下：</p><pre class="crayon-plain-tag">　　&lt;?php
　　　　session_start();
　　　　if (isset($_POST['toBankId'] &amp;&amp;　isset($_POST['money']))
　　　　{
　　　　    buy_stocks($_POST['toBankId'],　$_POST['money']);
　　　　}
　　?&gt;</pre><p>然而，危险网站B与时俱进，它改了一下代码：</p><pre class="crayon-plain-tag">&lt;html&gt;
　　&lt;head&gt;
　　　　&lt;script type="text/javascript"&gt;
　　　　　　function steal()
　　　　　　{
          　　　　 iframe = document.frames["steal"];
　　     　　      iframe.document.Submit("transfer");
　　　　　　}
　　　　&lt;/script&gt;
　　&lt;/head&gt;

　　&lt;body onload="steal()"&gt;
　　　　&lt;iframe name="steal" display="none"&gt;
　　　　　　&lt;form method="POST" name="transfer"　action="http://www.myBank.com/Transfer.php"&gt;
　　　　　　　　&lt;input type="hidden" name="toBankId" value="11"&gt;
　　　　　　　　&lt;input type="hidden" name="money" value="1000"&gt;
　　　　　　&lt;/form&gt;
　　　　&lt;/iframe&gt;
　　&lt;/body&gt;
&lt;/html&gt;</pre><p>如果用户仍是继续上面的操作，很不幸，结果将会是再次不见1000块&#8230;&#8230;因为这里危险网站B暗地里发送了POST请求到银行!</p>
<p>总结一下上面3个例子，CSRF主要的攻击模式基本上是以上的3种，其中以第1,2种最为严重，因为触发条件很简单，一个&lt;img&gt;就可以了，而第3种比较麻烦，需要使用JavaScript，所以使用的机会会比前面的少很多，但无论是哪种情况，只要触发了CSRF攻击，后果都有可能很严重。</p>
<p>理解上面的3种攻击模式，其实可以看出，CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！</p>
<h2><b>CSRF的防御</b></h2>
<p>我总结了一下看到的资料，CSRF的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的CSRF防御也都在服务端进行。</p>
<h3>　　<b>1.服务端进行CSRF防御</b></h3>
<p>服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。</p>
<p>(1).Cookie Hashing(所有表单都包含同一个伪随机值)：</p>
<p>这可能是最简单的解决方案了，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了:&gt;</p><pre class="crayon-plain-tag">　　&lt;?php
　　　　//构造加密的Cookie信息
　　　　$value = “DefenseSCRF”;
　　　　setcookie(”cookie”, $value, time()+3600);
　　?&gt;</pre><p>在表单里增加Hash值，以认证这确实是用户发送的请求。</p><pre class="crayon-plain-tag">　　&lt;?php
　　　　$hash = md5($_COOKIE['cookie']);
　　?&gt;
　　&lt;form method=”POST” action=”transfer.php”&gt;
　　　　&lt;input type=”text” name=”toBankId”&gt;
　　　　&lt;input type=”text” name=”money”&gt;
　　　　&lt;input type=”hidden” name=”hash” value=”&lt;?=$hash;?&gt;”&gt;
　　　　&lt;input type=”submit” name=”submit” value=”Submit”&gt;
　　&lt;/form&gt;</pre><p>然后在服务器端进行Hash值验证</p><pre class="crayon-plain-tag">      &lt;?php
　　      if(isset($_POST['check'])) {
     　　      $hash = md5($_COOKIE['cookie']);
          　　 if($_POST['check'] == $hash) {
               　　 doJob();
　　           } else {
　　　　　　　　//...
          　　 }
　　      } else {
　　　　　　//...
　　      }
      ?&gt;</pre><p>这个方法个人觉得已经可以杜绝99%的CSRF攻击了，那还有1%呢&#8230;.由于用户的Cookie很容易由于网站的XSS漏洞而被盗取，这就另外的1%。一般的攻击者看到有需要算Hash值，基本都会放弃了，某些除外，所以如果需要100%的杜绝，这个不是最好的方法。</p>
<h3>
2.验证码</h3>
<p>这个方案的思路是：每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，厄&#8230;.这个方案可以完全解决CSRF，但个人觉得在易用性方面似乎不是太好，还有听闻是验证码图片的使用涉及了一个被称为MHTML的Bug，可能在某些版本的微软IE中受影响。</p>
<h2>原文链接</h2>
<p>在网上发现这篇文章说得很明了，转载啦，非常感谢原作者的辛苦付出。</p>
<p><a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html">原文出处</a></p>
<p>转载请注明：<a href="http://blog.cuiqingcai.com">静觅</a> &raquo; <a href="http://blog.cuiqingcai.com/2076.html">浅谈CSRF攻击方式</a></p>]]></content:encoded>
			<wfw:commentRss>http://blog.cuiqingcai.com/2076.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>怎样把你的SAE利用起来</title>
		<link>http://blog.cuiqingcai.com/2057.html</link>
		<comments>http://blog.cuiqingcai.com/2057.html#comments</comments>
		<pubDate>Sat, 12 Sep 2015 08:17:41 +0000</pubDate>
		<dc:creator><![CDATA[崔庆才]]></dc:creator>
				<category><![CDATA[Other]]></category>
		<category><![CDATA[福利专区]]></category>

		<guid isPermaLink="false">http://cuiqingcai.com/?p=2057</guid>
		<description><![CDATA[综述 博主没事就喜欢瞎倒腾，今天登录自己的SAE一看，很久之前挂的几个应用早已杳无人烟，才消耗几个云豆，真是觉 [&#8230;]]]></description>
				<content:encoded><![CDATA[<h2>综述</h2>
<p>博主没事就喜欢瞎倒腾，今天登录自己的SAE一看，很久之前挂的几个应用早已杳无人烟，才消耗几个云豆，真是觉得太浪费了。所以博主就瞎倒腾一下，准备好好利用起自己的云豆，尽可能地为我提供服务。</p>
<p>好了，废话不多说，让我们开始动起来！</p>
<h2>新建应用</h2>
<p>既然想利用好里面的服务，那么我们就需要新建一个专属应用，取个专属名称，那么我名字叫崔庆才，那就叫cuiqingcai好了，幸运的是，并没有同名应用，可以使用，不错不错。</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150912153748.png"><img class="alignnone size-full wp-image-2059" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150912153748.png" alt="20150912153748" width="1292" height="357" /></a></p>
<h2>数据库</h2>
<p>SAE上最近出了一种独享数据库，不像之前的数据库一样每建一个应用自动生成一个数据库，这个数据库就像平常我们用到的phpMyAdmin一样一样的。可以新建好多个数据库，可以远程连接，可以登录网页设置。</p>
<p>有了这个，如果你没有VPS，也不需要去买个RDS来用啦！</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150912152842.png"><img class="alignnone size-full wp-image-2058" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150912152842.png" alt="20150912152842" width="568" height="423" /></a></p>
<p>&nbsp;</p>
<p>首先建立好应用之后，到应用管理界面去，点击你的MySQL，然后就会让你选择是哪一种数据库，右边的独享型MySQL是SAE新出的，功能也非常强，可以建立数据库，可以建用户，授权数据库，监控数据等等。</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150912153909.png"><img class="alignnone size-large wp-image-2060" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150912153909-1024x538.png" alt="20150912153909" width="1024" height="538" /></a></p>
<p>点击独享型MySQL，创建属于自己的数据库吧。创建好了，建立自己的账户，登进来，一切都是那么轻松加愉快，以后有什么需要数据库，扔到这里就好了。</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150912154219.png"><img class="alignnone size-large wp-image-2061" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150912154219-1024x432.png" alt="20150912154219" width="1024" height="432" /></a></p>
<p>好，相信这个一定非常简单，小伙伴们快试一下吧！</p>
<h2>Storage</h2>
<p>新浪云中提供了SCS，也是一个云存储服务，但是费用太坑了，而且不是消耗云豆的，然而应用中的Storage是使用云豆的，如果不是什么私密存储的话，还是可以利用一下的。</p>
<p>在这里我想让它发挥SCS的作用并绑定到我的域名上，这样通过scs.cuiqingcai.com便可以访问了。</p>
<p>我们新建一个Storage Domain</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150912155842.png"><img class="alignnone size-large wp-image-2062" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150912155842-1024x368.png" alt="20150912155842" width="1024" height="368" /></a></p>
<p>上传一张图片进去，比如1.jpg，上传后访问一下</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150912160138.png"><img class="alignnone size-full wp-image-2063" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150912160138.png" alt="20150912160138" width="564" height="282" /></a></p>
<p>&nbsp;</p>
<p>恩，轻松加愉快！接下来，我发现这个域名简直太难记了，我要换成自己的域名，比如 scs.cuiqingcai.com</p>
<p>这样，图片就可以通过 scs.cuiqingcai.com/1.jpg 来访问了。那么怎么配置呢？</p>
<h3>1.绑定域名</h3>
<p>到应用首页里面，点击域名绑定，SAE会告诉你两条要解析的内容，自己设置一下</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150912160935.png"><img class="alignnone size-full wp-image-2064" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150912160935.png" alt="20150912160935" width="655" height="390" /></a></p>
<p>接下来我们需要配置一下代码</p>
<h3>2.修改config.yaml</h3>
<p>需要在代码管理中，更改一下config.yaml文件，让它做一个跳转。</p>
<p>比如我的代码中 config.yaml 文件就更改为</p><pre class="crayon-plain-tag">name: cuiqingcai
version: 1
handle:
	- rewrite: if (path ~ "/(.*)") goto "http://cuiqingcai-scs.stor.sinaapp.com/$1"</pre><p>其实就是加了一条reweite语句，把所有的路径定位到新地址的新路径中。</p>
<p>接下来，我访问一下 scs.cuiqingcai.com/1.jpg，嗯，图片出来了！这样，又一个免费的CDN建好了！</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150912161437.png"><img class="alignnone size-full wp-image-2065" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150912161437.png" alt="20150912161437" width="557" height="256" /></a></p>
<p>嗯，如果有什么图片需要存放，它会是你的一个非常好的选择！</p>
<p>上传的话，SAE提供了上传的客户端，大家可以自行下载尝试。</p>
<p>之后博主将研究一下怎样配置上传的接口，这样我们就可以通过程序来上传了，我也很期待呢！</p>
<h2>结语</h2>
<p>以上是博主瞎倒腾的，可以为自己提供一些方便，大家尝试下吧，如有问题，欢迎留言交流！</p>
<p>转载请注明：<a href="http://blog.cuiqingcai.com">静觅</a> &raquo; <a href="http://blog.cuiqingcai.com/2057.html">怎样把你的SAE利用起来</a></p>]]></content:encoded>
			<wfw:commentRss>http://blog.cuiqingcai.com/2057.html/feed</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>Ubuntu Linux配置Nginx+MySQL+PHP+phpMyAdmin详细步骤</title>
		<link>http://blog.cuiqingcai.com/2036.html</link>
		<comments>http://blog.cuiqingcai.com/2036.html#comments</comments>
		<pubDate>Fri, 11 Sep 2015 07:23:36 +0000</pubDate>
		<dc:creator><![CDATA[崔庆才]]></dc:creator>
				<category><![CDATA[Linux]]></category>
		<category><![CDATA[Mysql]]></category>
		<category><![CDATA[Nginx]]></category>
		<category><![CDATA[PHP]]></category>

		<guid isPermaLink="false">http://cuiqingcai.com/?p=2036</guid>
		<description><![CDATA[博主之前一直用的是apache，随着网站负荷量增高，感觉apache稍微有点力不从心了。随着nginx越来越流 [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>博主之前一直用的是apache，随着网站负荷量增高，感觉apache稍微有点力不从心了。随着nginx越来越流行，而且其功能强大，博主准备采用nginx作为自己的服务器啦。</p>
<p>每当到了环境配置的时候，博主便会去网上各种搜集资料，然而感觉他们讲的都条理不一，有的地方并不符合自己的配置习惯，所以博主习惯自己配置的同时把配置过程总结一下，方便自己，也方便大家。</p>
<p>好，接下来我们就开始我们的环境配置之旅吧。</p>
<h2>Nginx</h2>
<h3>1.更新源</h3>
<p></p><pre class="crayon-plain-tag">sudo apt-get update</pre><p></p>
<h3>2.安装nginx</h3>
<p></p><pre class="crayon-plain-tag">sudo apt-get install nginx</pre><p></p>
<h3>3.检查是否安装成功</h3>
<p>输入localhost或者远程地址，若出现Welcome To Nginx则证明安装成功。</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150911144903.png"><img class="alignnone size-full wp-image-2038" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150911144903.png" alt="20150911144903" width="542" height="220" /></a></p>
<p>如果没有看到，可以运行</p><pre class="crayon-plain-tag">sudo killall apache2</pre><p>杀掉apache进程，因为可能80端口被占用了。</p>
<h3>4.更改运行目录</h3>
<p>默认的nginx目录是/usr/share/nginx/html，我们将其修改为/var/www，当然可以根据个人习惯灵活更改。</p>
<p>修改/etc/nginx/sites-available/default文件</p><pre class="crayon-plain-tag">root /usr/share/nginx/html;</pre><p>更改为</p><pre class="crayon-plain-tag">root /var/www</pre><p>再将</p><pre class="crayon-plain-tag">index index.html index.htm;</pre><p>更改为</p><pre class="crayon-plain-tag">index index.html index.php index.htm;</pre><p>重启nginx</p><pre class="crayon-plain-tag">sudo service nginx restart</pre><p>我们在/var/www目录下新建index.html文件，写入一些测试文字。</p>
<p>重新访问localhost或者远程地址，可以看到刚才设置的index.html文件中的内容，说明目录已经更改成功了。</p>
<h2>PHP</h2>
<p>安装PHP以及相关扩展。</p><pre class="crayon-plain-tag">sudo apt-get install php5 php5-cgi php5-mysql php5-curl php5-gd php5-idn php-pear php5-imagick php5-imap php5-mcrypt php5-memcache php5-mhash php5-ming php5-pspell php5-recode php5-snmp php5-tidy php5-xmlrpc php5-sqlite php5-xsl</pre><p>执行上述指令即可。</p>
<p>此时有的小伙伴想要测试运行PHP文件了，然而很悲剧地告诉你是不可以的，因为你还没有配置fastcgi，继续往下看。</p>
<h2>MySQL</h2>
<p>执行如下命令，安装MySQL服务端和客户端。</p><pre class="crayon-plain-tag">sudo apt-get install mysql-server mysql-client</pre><p>在安装时可能提示你输入root用户的密码，设置即可。</p>
<h2>phpMyAdmin</h2>
<p>执行如下命令，安装phpMyAdmin。</p><pre class="crayon-plain-tag">sudo apt-get install phpmyadmin</pre><p>创建软连接</p><pre class="crayon-plain-tag">sudo ln -s /usr/share/phpmyadmin/ /var/www/phpmyadmin</pre><p>我们将创建一个根目录为/var/www，链接名为phpmyadmin的文件，指向/usr/share/phpmyadmin</p>
<h2>spawn-fcgi</h2>
<h3>1.安装fastcgi</h3>
<p></p><pre class="crayon-plain-tag">sudo apt-get install spawn-fcgi</pre><p></p>
<h3>2.配置fastcgi</h3>
<p>修改 /etc/nginx/fastcgi_params文件，增加下面一行</p><pre class="crayon-plain-tag">fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</pre><p>修改/etc/php5/cgi/php.ini文件，将下面一行取消注释</p><pre class="crayon-plain-tag">cgi.fix_pathinfo=1;</pre><p>这样php-cgi方能正常使用SCRIPT_FILENAME这个变量</p>
<p>修改/etc/nginx/sites-available/default文件，我们之前修改的目录地址是/var/www，将</p><pre class="crayon-plain-tag">#location ~ \.php$ {
	#	fastcgi_split_path_info ^(.+\.php)(/.+)$;
	#	# NOTE: You should have "cgi.fix_pathinfo = 0;" in php.ini
	#
	#	# With php5-cgi alone:
	#	fastcgi_pass 127.0.0.1:9000;
	#	# With php5-fpm:
	#	fastcgi_pass unix:/var/run/php5-fpm.sock;
	#	fastcgi_index index.php;
	#	include fastcgi_params;
	#}</pre><p>修改为</p><pre class="crayon-plain-tag">location ~ \.php$ {
	#	fastcgi_split_path_info ^(.+\.php)(/.+)$;
	#	# NOTE: You should have "cgi.fix_pathinfo = 0;" in php.ini
	#
	#	# With php5-cgi alone:
		fastcgi_pass 127.0.0.1:9000;
	#	# With php5-fpm:
	#	fastcgi_pass unix:/var/run/php5-fpm.sock;
		fastcgi_index index.php;
		fastcgi_param SCRIPT_FILENAME /var/www$fastcgi_script_name;
		include fastcgi_params;
	}</pre><p></p>
<h3>3.开启fastcgi进程</h3>
<p></p><pre class="crayon-plain-tag">sudo /usr/bin/spawn-fcgi -a 127.0.0.1 -p 9000 -C 5 -u www-data -g www-data -f /usr/bin/php5-cgi -P /var/run/fastcgi-php.pid</pre><p>参数含义如下</p>
<blockquote><p>　　* -f 指定调用FastCGI的进程的执行程序位置，根据系统上所装的PHP的情况具体设置</p>
<p>* -a 绑定到地址addr</p>
<p>* -p 绑定到端口port</p>
<p>* -s 绑定到unix socket的路径path</p>
<p>* -C 指定产生的FastCGI的进程数，默认为5（仅用于PHP）</p>
<p>* -P指定产生的进程的PID文件路径</p>
<p>* -u和-g FastCGI使用什么身份（-u 用户 -g 用户组）运行，Ubuntu下可以使用www-data,其他的根据情况配置，如nobody、apache等现在可以在web根目录下放个探针或php文件测试一下了</p></blockquote>
<p>运行结果类似如下</p><pre class="crayon-plain-tag">spawn-fcgi: child spawned successfully: PID: 11775</pre><p></p>
<h3>4.设置开机启动fastcgi</h3>
<p>修改/etc/rc.local文件，添加下面一行</p><pre class="crayon-plain-tag">/usr/bin/spawn-fcgi -a 127.0.0.1 -p 9000 -C 5 -u www-data -g www-data -f /usr/bin/php5-cgi -P /var/run/fastcgi-php.pid</pre><p>修改完之后，重启nginx</p><pre class="crayon-plain-tag">sudo service nginx restart</pre><p>我们可以在/var/www目录下新建index.php文件测试运行，发现已经可以运行PHP文件了。</p>
<h2>测试运行</h2>
<p>所有配置已经完毕，现在我们输入localhost和localhost/phpmyadmin便可以轻松加愉快地访问了。</p>
<p>如有问题，欢迎交流。</p>
<p>转载请注明：<a href="http://blog.cuiqingcai.com">静觅</a> &raquo; <a href="http://blog.cuiqingcai.com/2036.html">Ubuntu Linux配置Nginx+MySQL+PHP+phpMyAdmin详细步骤</a></p>]]></content:encoded>
			<wfw:commentRss>http://blog.cuiqingcai.com/2036.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Python爬虫实战六之抓取爱问知识人问题并保存至数据库</title>
		<link>http://blog.cuiqingcai.com/1972.html</link>
		<comments>http://blog.cuiqingcai.com/1972.html#comments</comments>
		<pubDate>Tue, 08 Sep 2015 14:24:33 +0000</pubDate>
		<dc:creator><![CDATA[崔庆才]]></dc:creator>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[爬虫]]></category>

		<guid isPermaLink="false">http://cuiqingcai.com/?p=1972</guid>
		<description><![CDATA[大家好，本次为大家带来的是抓取爱问知识人的问题并将问题和答案保存到数据库的方法，涉及的内容包括： Urllib [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>大家好，本次为大家带来的是抓取爱问知识人的问题并将问题和答案保存到数据库的方法，涉及的内容包括：</p>
<ul>
<li>Urllib的用法及异常处理</li>
<li>Beautiful Soup的简单应用</li>
<li>MySQLdb的基础用法</li>
<li>正则表达式的简单应用</li>
</ul>
<h2>环境配置</h2>
<p>在这之前，我们需要先配置一下环境，我的Python的版本为2.7，需要额外安装的库有两个，一个是Beautiful Soup，一个是MySQLdb，在这里附上两个库的下载地址，</p>
<p><a class="dl link" href="https://pypi.python.org/pypi/beautifulsoup4/4.3.2">Beautiful Soup</a>     <a class="dl link" href="http://sourceforge.net/projects/mysql-python/">MySQLdb</a></p>
<p>大家可以下载之后通过如下命令安装</p><pre class="crayon-plain-tag">python setup.py install</pre><p>环境配置好之后，我们便可以开心地撸爬虫了</p>
<h2>框架思路</h2>
<p>首先我们随便找一个分类地址，<a href="http://iask.sina.com.cn/c/978-all-1.html">外语学习 &#8211; 爱问知识人</a>，打开之后可以看到一系列的问题列表。</p>
<p>我们在这个页面需要获取的东西有：</p>
<p>总的页码数，每一页的所有问题链接。</p>
<p>接下来我们需要遍历所有的问题，来抓取每一个详情页面，提取问题，问题内容，回答者，回答时间，回答内容。</p>
<p>最后，我们需要把这些内容存储到数据库中。</p>
<h2>要点简析</h2>
<p>其实大部分内容相信大家会了前面的内容，这里的爬虫思路已经融汇贯通了，这里就说一下一些扩展的功能</p>
<h3>1.日志输出</h3>
<p>日志输出，我们要输出时间和爬取的状态，比如像下面这样：</p>
<blockquote><p>[2015-08-10 03:05:20] 113011 号问题存在其他答案 我个人认为应该是樱桃沟很美的</p>
<p>[2015-08-10 03:05:20] 保存到数据库,此问题的ID为 113011</p>
<p>[2015-08-10 03:05:20] 当前爬取第 2 的内容,发现一个问题 百度有一个地方，花儿带着芳香，水儿流淌奔腾是什么意思 多多帮忙哦 回答数量 1</p>
<p>[2015-08-10 03:05:19] 保存到数据库,此问题的ID为 113010</p></blockquote>
<p>所以，我们需要引入时间函数，然后写一个获取当前时间的函数</p><pre class="crayon-plain-tag">import time

#获取当前时间
def getCurrentTime(self):
    return time.strftime('[%Y-%m-%d %H:%M:%S]',time.localtime(time.time()))
    
#获取当前时间
def getCurrentDate(self):
    return time.strftime('%Y-%m-%d',time.localtime(time.time()))</pre><p>以上分别是获取带具体时间和获取日期的函数，在输出时，我们可以在输出语句的前面调用这函数即可。</p>
<p>然后我们需要将缓冲区设置输出到log中，在程序的最前面加上这两句即可</p><pre class="crayon-plain-tag">f_handler=open('out.log', 'w') 
sys.stdout=f_handler</pre><p>这样，所有的print语句输出的内容就会保存到out.log文件中了。</p>
<h3>2.页码保存</h3>
<p>爬虫爬取过程中可能出现各种各样的错误，这样会导致爬虫的中断，如果我们重新运行爬虫，那么就会导致爬虫从头开始运行了，这样显然是不合理的。所以，我们需要把当前爬取的页面保存下来，比如可以保存到文本中，假如爬虫中断了，重新运行爬虫，读取文本文件的内容，接着爬取即可。</p>
<p>大家可以稍微参考一下函数的实现：</p><pre class="crayon-plain-tag">#主函数
    def main(self):
        f_handler=open('out.log', 'w') 
        sys.stdout=f_handler
        page = open('page.txt', 'r')
        content = page.readline()
        start_page = int(content.strip()) - 1
        page.close()     
        print self.getCurrentTime(),"开始页码",start_page
        print self.getCurrentTime(),"爬虫正在启动,开始爬取爱问知识人问题"
        self.total_num = self.getTotalPageNum()
        print self.getCurrentTime(),"获取到目录页面个数",self.total_num,"个"
        if not start_page:
            start_page = self.total_num
        for x in range(1,start_page):
            print self.getCurrentTime(),"正在抓取第",start_page-x+1,"个页面"
            try:
                self.getQuestions(start_page-x+1)
            except urllib2.URLError, e:
                if hasattr(e, "reason"):
                    print self.getCurrentTime(),"某总页面内抓取或提取失败,错误原因", e.reason
            except Exception,e:  
                print self.getCurrentTime(),"某总页面内抓取或提取失败,错误原因:",e
            if start_page-x+1 &lt; start_page:
                f=open('page.txt','w')
                f.write(str(start_page-x+1))
                print self.getCurrentTime(),"写入新页码",start_page-x+1
                f.close()</pre><p>这样，不管我们爬虫中途遇到什么错误，妈妈也不会担心了</p>
<h3>3.页面处理</h3>
<p>页面处理过程中，我们可能遇到各种各样奇葩的HTML代码，和上一节一样，我们沿用一个页面处理类即可。</p><pre class="crayon-plain-tag">import re

#处理页面标签类
class Tool:
    
    #将超链接广告剔除
    removeADLink = re.compile('&lt;div class="link_layer.*?&lt;/div&gt;')
    #去除img标签,1-7位空格,&amp;nbsp;
    removeImg = re.compile('&lt;img.*?&gt;| {1,7}|&amp;nbsp;')
    #删除超链接标签
    removeAddr = re.compile('&lt;a.*?&gt;|&lt;/a&gt;')
    #把换行的标签换为\n
    replaceLine = re.compile('&lt;tr&gt;|&lt;div&gt;|&lt;/div&gt;|&lt;/p&gt;')
    #将表格制表&lt;td&gt;替换为\t
    replaceTD= re.compile('&lt;td&gt;')
    #将换行符或双换行符替换为\n
    replaceBR = re.compile('&lt;br&gt;&lt;br&gt;|&lt;br&gt;')
    #将其余标签剔除
    removeExtraTag = re.compile('&lt;.*?&gt;')
    #将多行空行删除
    removeNoneLine = re.compile('\n+')
    
    def replace(self,x):
        x = re.sub(self.removeADLink,"",x)
        x = re.sub(self.removeImg,"",x)
        x = re.sub(self.removeAddr,"",x)
        x = re.sub(self.replaceLine,"\n",x)
        x = re.sub(self.replaceTD,"\t",x)
        x = re.sub(self.replaceBR,"\n",x)
        x = re.sub(self.removeExtraTag,"",x)
        x = re.sub(self.removeNoneLine,"\n",x)
        #strip()将前后多余内容删除
        return x.strip()</pre><p>我们可以用一段含有HTML代码的文字，经过调用replace方法之后，各种冗余的HTML代码就会处理好了。</p>
<p>比如我们这么一段代码：</p><pre class="crayon-plain-tag">&lt;article class="article-content"&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;最近发现MySQL服务隔三差五就会挂掉，导致我的网站和爬虫都无法正常运作。自己的网站是基于MySQL，在做爬虫存取一些资料的时候也是基于MySQL，数据量一大了，MySQL它就有点受不了了，时不时会崩掉，虽然我自己有网站监控和邮件通知，但是好多时候还是需要我来手动连接我的服务器重新启动一下我的MySQL，这样简直太不友好了，所以，我就觉定自己写个脚本，定时监控它，如果发现它挂掉了就重启它。&lt;/p&gt;
&lt;p&gt;好了，闲言碎语不多讲，开始我们的配置之旅。&lt;/p&gt;
&lt;p&gt;运行环境：&lt;strong&gt;Ubuntu Linux 14.04&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;编写Shell脚本&lt;/h2&gt;
&lt;p&gt;首先，我们要编写一个shell脚本，脚本主要执行的逻辑如下：&lt;/p&gt;
&lt;p&gt;显示mysqld进程状态，如果判断进程未在运行，那么输出日志到文件，然后启动mysql服务，如果进程在运行，那么不执行任何操作，可以选择性输出监测结果。&lt;/p&gt;
&lt;p&gt;可能大家对于shell脚本比较陌生，在这里推荐官方的shell脚本文档来参考一下&lt;/p&gt;
&lt;p&gt;&lt;a href="http://wiki.ubuntu.org.cn/Shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80" data-original-title="" title=""&gt;Ubuntu Shell 编程基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;shell脚本的后缀为sh，在任何位置新建一个脚本文件，我选择在 /etc/mysql 目录下新建一个 listen.sh 文件。&lt;/p&gt;
&lt;p&gt;执行如下命令：&lt;/p&gt;</pre><p>经过处理后便会变成如下的样子：</p><pre class="crayon-plain-tag">前言
最近发现MySQL服务隔三差五就会挂掉，导致我的网站和爬虫都无法正常运作。自己的网站是基于MySQL，在做爬虫存取一些资料的时候也是基于MySQL，数据量一大了，MySQL它就有点受不了了，时不时会崩掉，虽然我自己有网站监控和邮件通知，但是好多时候还是需要我来手动连接我的服务器重新启动一下我的MySQL，这样简直太不友好了，所以，我就觉定自己写个脚本，定时监控它，如果发现它挂掉了就重启它。
好了，闲言碎语不多讲，开始我们的配置之旅。
运行环境：UbuntuLinux14.04
编写Shell脚本
首先，我们要编写一个shell脚本，脚本主要执行的逻辑如下：
显示mysqld进程状态，如果判断进程未在运行，那么输出日志到文件，然后启动mysql服务，如果进程在运行，那么不执行任何操作，可以选择性输出监测结果。
可能大家对于shell脚本比较陌生，在这里推荐官方的shell脚本文档来参考一下
UbuntuShell编程基础
shell脚本的后缀为sh，在任何位置新建一个脚本文件，我选择在/etc/mysql目录下新建一个listen.sh文件。
执行如下命令：</pre><p>经过上面的处理，所有乱乱的代码都会被处理好了。</p>
<h3>4.保存到数据库</h3>
<p>在这里，我们想实现一个通用的方法，就是把存储的一个个内容变成字典的形式，然后执行插入语句的时候，自动构建对应的sql语句，插入数据。</p>
<p>比如我们构造如下的字典：</p><pre class="crayon-plain-tag">#构造最佳答案的字典
good_ans_dict = {
        "text": good_ans[0],
        "answerer": good_ans[1],
        "date": good_ans[2],
        "is_good": str(good_ans[3]),
        "question_id": str(insert_id)
        }</pre><p>构造sql语句并插入到数据库的方法如下：</p><pre class="crayon-plain-tag">#插入数据
    def insertData(self, table, my_dict):
         try:
             self.db.set_character_set('utf8')
             cols = ', '.join(my_dict.keys())
             values = '"," '.join(my_dict.values())
             sql = "INSERT INTO %s (%s) VALUES (%s)" % (table, cols, '"'+values+'"')
             try:
                 result = self.cur.execute(sql)
                 insert_id = self.db.insert_id()
                 self.db.commit()
                 #判断是否执行成功
                 if result:
                     return insert_id
                 else:
                     return 0
             except MySQLdb.Error,e:
                 #发生错误时回滚
                 self.db.rollback()
                 #主键唯一，无法插入
                 if "key 'PRIMARY'" in e.args[1]:
                     print self.getCurrentTime(),"数据已存在，未插入数据"
                 else:
                     print self.getCurrentTime(),"插入数据失败，原因 %d: %s" % (e.args[0], e.args[1])
         except MySQLdb.Error,e:
             print self.getCurrentTime(),"数据库错误，原因%d: %s" % (e.args[0], e.args[1])</pre><p>这里我们只需要传入那个字典，便会构建出对应字典键值和键名的sql语句，完成插入。</p>
<h3>5.PHP读取日志</h3>
<p>我们将运行结果输出到了日志里，那么怎么查看日志呢？很简单，在这里提供两种方法</p>
<p>方法一：</p>
<p>PHP倒序输出所有日志内容</p><pre class="crayon-plain-tag">&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;meta http-equiv="refresh" content = "5"&gt; 
    &lt;/head&gt;
    &lt;body&gt;
        &lt;?php
            $fp = file("out.log");
            if ($fp) {
                for($i = count($fp) - 1;$i &gt;= 0; $i --) 
                echo $fp[$i]."&lt;br&gt;";
            }
        ?&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre><p>此方法可以看到所有的输入日志，但是如果日志太大了，那么就会报耗费内存太大，无法输出。为此我们就有了第二种方法，利用linux命令，输出后十行内容。</p>
<p>方法二：</p><pre class="crayon-plain-tag">&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;meta http-equiv="refresh" content = "5"&gt; 
    &lt;/head&gt;
    &lt;body&gt;
		&lt;?php 
			$ph = popen('tail -n 100 out.log','r');
			while($r = fgets($ph)){
				echo $r."&lt;br&gt;";
			}
			pclose($ph);
		?&gt;
	&lt;/body&gt;
&lt;/html&gt;</pre><p>上面两种方法都是5秒刷新一次网页来查看最新的日志。</p>
<h2>源代码放送</h2>
<p>好了，闲言碎语不多讲，直接上源码了</p><pre class="crayon-plain-tag">spider.py</pre><p></p><pre class="crayon-plain-tag"># -*- coding:utf-8 -*-

import urllib
import urllib2
import re
import time
import types
import page
import mysql
import sys
from bs4 import BeautifulSoup

class Spider:
    
    #初始化
    def __init__(self):
        self.page_num = 1
        self.total_num = None
        self.page_spider = page.Page()
        self.mysql = mysql.Mysql()
        
    #获取当前时间
    def getCurrentTime(self):
        return time.strftime('[%Y-%m-%d %H:%M:%S]',time.localtime(time.time()))
    
    #获取当前时间
    def getCurrentDate(self):
        return time.strftime('%Y-%m-%d',time.localtime(time.time()))
    
    #通过网页的页码数来构建网页的URL
    def getPageURLByNum(self, page_num):
        page_url = "http://iask.sina.com.cn/c/978-all-" + str(page_num) + ".html"
        return page_url
    
    
    #通过传入网页页码来获取网页的HTML
    def getPageByNum(self, page_num):
        request = urllib2.Request(self.getPageURLByNum(page_num))
        try:
            response = urllib2.urlopen(request)
        except urllib2.URLError, e:
            if hasattr(e, "code"):
                print self.getCurrentTime(),"获取页面失败,错误代号", e.code
                return None
            if hasattr(e, "reason"):
                print self.getCurrentTime(),"获取页面失败,原因", e.reason
                return None
        else:
            page =  response.read().decode("utf-8")
            return page
    
    #获取所有的页码数
    def getTotalPageNum(self):
        print self.getCurrentTime(),"正在获取目录页面个数,请稍候"
        page = self.getPageByNum(1)
        #匹配所有的页码数,\u4e0b\u4e00\u9875是下一页的UTF8编码
        pattern = re.compile(u'&lt;span class="more".*?&gt;.*?&lt;span.*?&lt;a href.*?class=""&gt;(.*?)&lt;/a&gt;\s*&lt;a.*?\u4e0b\u4e00\u9875&lt;/a&gt;', re.S)
        match = re.search(pattern, page)
        if match:
            return match.group(1)
        else:
            print self.getCurrentTime(),"获取总页码失败"
    
    #分析问题的代码,得到问题的提问者,问题内容,回答个数,提问时间
    def getQuestionInfo(self, question):
        if not type(question) is types.StringType:
            question = str(question)
        #print question
        pattern = re.compile(u'&lt;span.*?question-face.*?&gt;.*?&lt;img.*?alt="(.*?)".*?&lt;/span&gt;.*?&lt;a href="(.*?)".*?&gt;(.*?)&lt;/a&gt;.*?answer_num.*?&gt;(\d*).*?&lt;/span&gt;.*?answer_time.*?&gt;(.*?)&lt;/span&gt;', re.S)
        match = re.search(pattern, question)
        if match:
            #获得提问者
            author = match.group(1)
            #问题链接
            href = match.group(2)
            #问题详情
            text = match.group(3)
            #回答个数
            ans_num = match.group(4)
            #回答时间
            time = match.group(5)
            time_pattern = re.compile('\d{4}\-\d{2}\-\d{2}', re.S)
            time_match = re.search(time_pattern, time)
            if not time_match:
                time = self.getCurrentDate()
            return [author, href, text, ans_num, time]
        else:
            return None
        
    #获取全部问题
    def getQuestions(self, page_num):
        #获得目录页面的HTML
        page = self.getPageByNum(page_num)
        soup = BeautifulSoup(page)
        #分析获得所有问题
        questions = soup.select("div.question_list ul li")
        #遍历每一个问题
        for question in questions:
            #获得问题的详情
            info = self.getQuestionInfo(question)
            if info:
                #得到问题的URL
                url = "http://iask.sina.com.cn/" + info[1]
                #通过URL来获取问题的最佳答案和其他答案
                ans = self.page_spider.getAnswer(url)
                print self.getCurrentTime(),"当前爬取第",page_num,"的内容,发现一个问题",info[2],"回答数量",info[3]
                #构造问题的字典,插入问题
                ques_dict = {
                            "text": info[2],
                            "questioner": info[0],
                            "date": info[4],
                            "ans_num": info[3],
                            "url": url
                            }
                #获得插入的问题的自增ID 
                insert_id = self.mysql.insertData("iask_questions",ques_dict)
                #得到最佳答案
                good_ans = ans[0]
                print self.getCurrentTime(),"保存到数据库,此问题的ID为",insert_id
                #如果存在最佳答案,那么就插入
                if good_ans:
                    print self.getCurrentTime(),insert_id,"号问题存在最佳答案",good_ans[0]
                    #构造最佳答案的字典
                    good_ans_dict = {
                            "text": good_ans[0],
                            "answerer": good_ans[1],
                            "date": good_ans[2],
                            "is_good": str(good_ans[3]),
                            "question_id": str(insert_id)
                            }
                    #插入最佳答案
                    if self.mysql.insertData("iask_answers",good_ans_dict):
                        print self.getCurrentTime(),"保存最佳答案成功"
                    else:
                        print self.getCurrentTime(),"保存最佳答案失败"
                #获得其他答案
                other_anses = ans[1]
                #遍历每一个其他答案
                for other_ans in other_anses:
                    #如果答案存在
                    if other_ans:
                        print self.getCurrentTime(),insert_id,"号问题存在其他答案",other_ans[0]
                        #构造其他答案的字典
                        other_ans_dict = {
                                "text": other_ans[0],
                                "answerer": other_ans[1],
                                "date": other_ans[2],
                                "is_good": str(other_ans[3]),
                                "question_id": str(insert_id)
                                }
                        #插入这个答案
                        if self.mysql.insertData("iask_answers",other_ans_dict):
                            print self.getCurrentTime(),"保存其他答案成功"
                        else:
                            print self.getCurrentTime(),"保存其他答案失败"
        
    #主函数
    def main(self):
        f_handler=open('out.log', 'w') 
        sys.stdout=f_handler
        page = open('page.txt', 'r')
        content = page.readline()
        start_page = int(content.strip()) - 1
        page.close()     
        print self.getCurrentTime(),"开始页码",start_page
        print self.getCurrentTime(),"爬虫正在启动,开始爬取爱问知识人问题"
        self.total_num = self.getTotalPageNum()
        print self.getCurrentTime(),"获取到目录页面个数",self.total_num,"个"
        if not start_page:
            start_page = self.total_num
        for x in range(1,start_page):
            print self.getCurrentTime(),"正在抓取第",start_page-x+1,"个页面"
            try:
                self.getQuestions(start_page-x+1)
            except urllib2.URLError, e:
                if hasattr(e, "reason"):
                    print self.getCurrentTime(),"某总页面内抓取或提取失败,错误原因", e.reason
            except Exception,e:  
                print self.getCurrentTime(),"某总页面内抓取或提取失败,错误原因:",e
            if start_page-x+1 &lt; start_page:
                f=open('page.txt','w')
                f.write(str(start_page-x+1))
                print self.getCurrentTime(),"写入新页码",start_page-x+1
                f.close()

spider = Spider()
spider.main()</pre><p></p><pre class="crayon-plain-tag">page.py</pre><p></p><pre class="crayon-plain-tag"># -*- coding:utf-8 -*-
import urllib
import urllib2
import re
import time
import types 
import tool
from bs4 import BeautifulSoup

#抓取分析某一问题和答案
class Page:
    
    def __init__(self):
        self.tool = tool.Tool()
    
    #获取当前时间
    def getCurrentDate(self):
        return time.strftime('%Y-%m-%d',time.localtime(time.time()))
    
    #获取当前时间
    def getCurrentTime(self):
        return time.strftime('[%Y-%m-%d %H:%M:%S]',time.localtime(time.time()))

    #通过页面的URL来获取页面的代码
    def getPageByURL(self, url):
        try:
            request = urllib2.Request(url)
            response = urllib2.urlopen(request)
            return response.read().decode("utf-8") 
        except urllib2.URLError, e:
            if hasattr(e, "code"):
                print self.getCurrentTime(),"获取问题页面失败,错误代号", e.code
                return None
            if hasattr(e, "reason"):
                print self.getCurrentTime(),"获取问题页面失败,原因", e.reason
                return None

    
    #传入一个List,返回它的标签里的内容,如果为空返回None
    def getText(self, html):
        if not type(html) is types.StringType:
            html = str(html)
        #提取出&lt;pre&gt;标签里的内容
        pattern = re.compile('&lt;pre.*?&gt;(.*?)&lt;/pre&gt;', re.S)
        match = re.search(pattern, html)
        #如果匹配成功
        if match:
            return match.group(1)
        else: 
            return None
    
    #传入最佳答案的HTML,分析出回答者和回答时间
    def getGoodAnswerInfo(self, html):
        pattern = re.compile('"answer_tip.*?&lt;a.*?&gt;(.*?)&lt;/a&gt;.*?&lt;span class="time.*?&gt;.*?\|(.*?)&lt;/span&gt;', re.S)
        match = re.search(pattern, html)
        #如果匹配,返回回答者和回答时间
        if match:
            time = match.group(2)
            time_pattern = re.compile('\d{2}\-\d{2}\-\d{2}', re.S)
            time_match = re.search(time_pattern, time)
            if not time_match:
                time = self.getCurrentDate()
            else:
                time = "20"+time
            return [match.group(1),time]
        else:
            return [None,None]
    
    #获得最佳答案
    def getGoodAnswer(self, page):
        soup = BeautifulSoup(page)
        text = soup.select("div.good_point div.answer_text pre")
        if len(text) &gt; 0:
            #获得最佳答案的内容
            ansText = self.getText(str(text[0]))
            ansText = self.tool.replace(ansText)
            #获得最佳答案的回答者信息
            info = soup.select("div.good_point div.answer_tip")
            ansInfo = self.getGoodAnswerInfo(str(info[0]))
            #将三者组合成一个List
            answer = [ansText, ansInfo[0], ansInfo[1],1]
            return answer
        else:
            #如果不存在最佳答案,那么就返回空
            return None
    
    #传入回答者HTML,分析出回答者,回答时间
    def getOtherAnswerInfo(self, html):
        if not type(html) is types.StringType:
            html = str(html)
        pattern = re.compile('"author_name.*?&gt;(.*?)&lt;/a&gt;.*?answer_t"&gt;(.*?)&lt;/span&gt;', re.S)
        match = re.search(pattern, html)
        #获得每一个回答的回答者信息和回答时间
        if match:
            time = match.group(2)
            time_pattern = re.compile('\d{2}\-\d{2}\-\d{2}', re.S)
            time_match = re.search(time_pattern, time)
            if not time_match:
                time = self.getCurrentDate()
            else:
                time = "20"+time
            return [match.group(1),time]
        else:
            return [None,None]
    
            
    #获得其他答案
    def getOtherAnswers(self, page):
        soup = BeautifulSoup(page)
        results =  soup.select("div.question_box li.clearfix .answer_info")
        #所有答案,包含好多个List,每个List包含了回答内容,回答者,回答时间
        answers = []
        for result in results:
            #获得回答内容
            ansSoup = BeautifulSoup(str(result))
            text = ansSoup.select(".answer_txt span pre")
            ansText = self.getText(str(text[0]))
            ansText = self.tool.replace(ansText)
            #获得回答者和回答时间
            info = ansSoup.select(".answer_tj")
            ansInfo = self.getOtherAnswerInfo(info[0])
            #将三者组合成一个List
            answer = [ansText, ansInfo[0], ansInfo[1],0]
            #加入到answers
            answers.append(answer)
        return answers
     
     #主函数
    def getAnswer(self, url):
        if not url:
            url = "http://iask.sina.com.cn/b/gQiuSNCMV.html"
        page = self.getPageByURL(url)
        good_ans = self.getGoodAnswer(page)
        other_ans = self.getOtherAnswers(page)
        return [good_ans,other_ans]


page = Page()
page.getAnswer(None)</pre><p></p><pre class="crayon-plain-tag">tool.py</pre><p></p><pre class="crayon-plain-tag">#-*- coding:utf-8 -*-
import re

#处理页面标签类
class Tool:
    
    #将超链接广告剔除
    removeADLink = re.compile('&lt;div class="link_layer.*?&lt;/div&gt;')
    #去除img标签,1-7位空格,&amp;nbsp;
    removeImg = re.compile('&lt;img.*?&gt;| {1,7}|&amp;nbsp;')
    #删除超链接标签
    removeAddr = re.compile('&lt;a.*?&gt;|&lt;/a&gt;')
    #把换行的标签换为\n
    replaceLine = re.compile('&lt;tr&gt;|&lt;div&gt;|&lt;/div&gt;|&lt;/p&gt;')
    #将表格制表&lt;td&gt;替换为\t
    replaceTD= re.compile('&lt;td&gt;')
    #将换行符或双换行符替换为\n
    replaceBR = re.compile('&lt;br&gt;&lt;br&gt;|&lt;br&gt;')
    #将其余标签剔除
    removeExtraTag = re.compile('&lt;.*?&gt;')
    #将多行空行删除
    removeNoneLine = re.compile('\n+')
    
    def replace(self,x):
        x = re.sub(self.removeADLink,"",x)
        x = re.sub(self.removeImg,"",x)
        x = re.sub(self.removeAddr,"",x)
        x = re.sub(self.replaceLine,"\n",x)
        x = re.sub(self.replaceTD,"\t",x)
        x = re.sub(self.replaceBR,"\n",x)
        x = re.sub(self.removeExtraTag,"",x)
        x = re.sub(self.removeNoneLine,"\n",x)
        #strip()将前后多余内容删除
        return x.strip()</pre><p></p><pre class="crayon-plain-tag">mysql.py</pre><p></p><pre class="crayon-plain-tag"># -*- coding:utf-8 -*-


import MySQLdb
import time

class Mysql:
    
    #获取当前时间
    def getCurrentTime(self):
        return time.strftime('[%Y-%m-%d %H:%M:%S]',time.localtime(time.time()))
    
    #数据库初始化
    def __init__(self):
        try:
            self.db = MySQLdb.connect('ip','username','password','db_name')
            self.cur = self.db.cursor()
        except MySQLdb.Error,e:
             print self.getCurrentTime(),"连接数据库错误，原因%d: %s" % (e.args[0], e.args[1])

    #插入数据
    def insertData(self, table, my_dict):
         try:
             self.db.set_character_set('utf8')
             cols = ', '.join(my_dict.keys())
             values = '"," '.join(my_dict.values())
             sql = "INSERT INTO %s (%s) VALUES (%s)" % (table, cols, '"'+values+'"')
             try:
                 result = self.cur.execute(sql)
                 insert_id = self.db.insert_id()
                 self.db.commit()
                 #判断是否执行成功
                 if result:
                     return insert_id
                 else:
                     return 0
             except MySQLdb.Error,e:
                 #发生错误时回滚
                 self.db.rollback()
                 #主键唯一，无法插入
                 if "key 'PRIMARY'" in e.args[1]:
                     print self.getCurrentTime(),"数据已存在，未插入数据"
                 else:
                     print self.getCurrentTime(),"插入数据失败，原因 %d: %s" % (e.args[0], e.args[1])
         except MySQLdb.Error,e:
             print self.getCurrentTime(),"数据库错误，原因%d: %s" % (e.args[0], e.args[1])</pre><p>数据库建表SQL如下：</p><pre class="crayon-plain-tag">CREATE TABLE IF NOT EXISTS `iask_answers` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '自增ID',
  `text` text NOT NULL COMMENT '回答内容',
  `question_id` int(18) NOT NULL COMMENT '问题ID',
  `answerer` varchar(255) NOT NULL COMMENT '回答者',
  `date` varchar(255) NOT NULL COMMENT '回答时间',
  `is_good` int(11) NOT NULL COMMENT '是否是最佳答案',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;

CREATE TABLE IF NOT EXISTS `iask_questions` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '问题ID',
  `text` text NOT NULL COMMENT '问题内容',
  `questioner` varchar(255) NOT NULL COMMENT '提问者',
  `date` date NOT NULL COMMENT '提问时间',
  `ans_num` int(11) NOT NULL COMMENT '回答数量',
  `url` varchar(255) NOT NULL COMMENT '问题链接',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;</pre><p>运行的时候执行如下命令即可</p><pre class="crayon-plain-tag">nohup python spider.py &amp;</pre><p>代码写的不好，仅供大家学习参考使用，如有问题，欢迎留言交流。</p>
<h2>运行结果查看</h2>
<p>我们把PHP文件和log文件放在同一目录下，运行PHP文件，便可以看到如下的内容：</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150908222744.png"><img class="alignnone size-full wp-image-2018" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/09/20150908222744.png" alt="20150908222744" width="1294" height="575" /></a></p>
<p>小伙伴们赶快试一下吧。</p>
<p>转载请注明：<a href="http://blog.cuiqingcai.com">静觅</a> &raquo; <a href="http://blog.cuiqingcai.com/1972.html">Python爬虫实战六之抓取爱问知识人问题并保存至数据库</a></p>]]></content:encoded>
			<wfw:commentRss>http://blog.cuiqingcai.com/1972.html/feed</wfw:commentRss>
		<slash:comments>3</slash:comments>
		</item>
		<item>
		<title>Ubuntu Linux下定时监测MySQL进程终止时自动重启的方法</title>
		<link>http://blog.cuiqingcai.com/1981.html</link>
		<comments>http://blog.cuiqingcai.com/1981.html#comments</comments>
		<pubDate>Sun, 16 Aug 2015 09:06:30 +0000</pubDate>
		<dc:creator><![CDATA[崔庆才]]></dc:creator>
				<category><![CDATA[Other]]></category>
		<category><![CDATA[Mysql]]></category>

		<guid isPermaLink="false">http://cuiqingcai.com/?p=1981</guid>
		<description><![CDATA[前言 最近发现MySQL服务隔三差五就会挂掉，导致我的网站和爬虫都无法正常运作。自己的网站是基于MySQL，在 [&#8230;]]]></description>
				<content:encoded><![CDATA[<h2>前言</h2>
<p>最近发现MySQL服务隔三差五就会挂掉，导致我的网站和爬虫都无法正常运作。自己的网站是基于MySQL，在做爬虫存取一些资料的时候也是基于MySQL，数据量一大了，MySQL它就有点受不了了，时不时会崩掉，虽然我自己有网站监控和邮件通知，但是好多时候还是需要我来手动连接我的服务器重新启动一下我的MySQL，这样简直太不友好了，所以，我就觉定自己写个脚本，定时监控它，如果发现它挂掉了就重启它。</p>
<p>好了，闲言碎语不多讲，开始我们的配置之旅。</p>
<p>运行环境：<strong>Ubuntu Linux 14.04</strong></p>
<h2>编写Shell脚本</h2>
<p>首先，我们要编写一个shell脚本，脚本主要执行的逻辑如下：</p>
<p>显示mysqld进程状态，如果判断进程未在运行，那么输出日志到文件，然后启动mysql服务，如果进程在运行，那么不执行任何操作，可以选择性输出监测结果。</p>
<p>可能大家对于shell脚本比较陌生，在这里推荐官方的shell脚本文档来参考一下</p>
<p><a href="http://wiki.ubuntu.org.cn/Shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80">Ubuntu Shell 编程基础</a></p>
<p>shell脚本的后缀为sh，在任何位置新建一个脚本文件，我选择在 /etc/mysql 目录下新建一个 listen.sh 文件。</p>
<p>执行如下命令：</p><pre class="crayon-plain-tag">cd /etc/mysql
touch listen.sh
vi listen.sh</pre><p>进入到vi中，我们添加如下脚本内容：</p><pre class="crayon-plain-tag">#!/bin/bash
pgrep mysqld &amp;&gt; /dev/null
if [ $? -gt 0 ]
then
echo "`date` mysql is stop"
service mysql start
else
echo "`date` mysql running"
fi</pre><p>其中 pgrep mysqld 是监测mysqld服务的运行状态，&amp;&gt; /dev/null 是将其结果输出到空文件，也就是不保存输出信息</p>
<p>$? 是拿到上一条命令的运行结果，-gt 0 是判断是否大于0，后面则是输出时间到日志文件，然后启动mysql，否则不启动mysql</p>
<p>保存好了，那么我们执行如下的命令，来测试一下。</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/08/20150816164552.jpg"><img class="alignnone size-full wp-image-1983" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/08/20150816164552.jpg" alt="20150816164552" width="461" height="228" /></a></p>
<p>&nbsp;</p>
<p>贴心的命令文字版本：</p><pre class="crayon-plain-tag">root@iZ28uogb3laZ:/etc/mysql# vi listen.sh
root@iZ28uogb3laZ:/etc/mysql# pgrep mysqld
3359
root@iZ28uogb3laZ:/etc/mysql# chmod 777 listen.sh
root@iZ28uogb3laZ:/etc/mysql# ./listen.sh
Sun Aug 16 16:44:58 CST 2015 mysql running
root@iZ28uogb3laZ:/etc/mysql# sudo service mysql stop
mysql stop/waiting
root@iZ28uogb3laZ:/etc/mysql# ./listen.sh
Sun Aug 16 16:45:17 CST 2015 mysql is stop
mysql start/running, process 4084
root@iZ28uogb3laZ:/etc/mysql# ./listen.sh
Sun Aug 16 16:45:24 CST 2015 mysql running
root@iZ28uogb3laZ:/etc/mysql#</pre><p>嗯，编辑完了.sh文件之后，我们首先要对其进行授权，增加可执行的权限。</p><pre class="crayon-plain-tag">sudo chmod 777 listen.sh</pre><p>然后运行脚本测试一下，显示mysql正在运行。把mysql关掉，运行脚本，便会检测到mysql已关闭，然后重新启动了mysql，再次运行，便会发现mysql正常运行了。</p>
<p><strong>注：这里我比较纳闷shell脚本中pgrep mysqld的返回结果是什么。为什么它大于0便代表mysql服务挂掉了呢？感觉逻辑有点是相反的，不过实测可用有效。如果大家明白为什么，非常希望您可以给我一个解释。</strong></p>
<h2>修改日志输出</h2>
<p>好，接下来我们把输出的内容保存到日志里。修改脚本文件如下</p><pre class="crayon-plain-tag">#!/bin/bash
pgrep mysqld &amp;&gt; /dev/null
if [ $? -gt 0 ]
then
echo "`date` mysql is stop" &gt;&gt; /var/log/mysql_listen.log
service mysql start
else
echo "`date` mysql running" &gt;&gt; /var/log/mysql_listen.log
fi</pre><p>这样，每执行一次脚本，输出结果都会被保存到 /var/log/mysql_listen.log 中了。</p>
<h2>添加定时任务</h2>
<p>好了，脚本可以顺利执行了，那么我们就需要定时调用一下这个脚本来运行了，我们需要用到 cron。</p>
<p>首先我们需要编辑一下corn调度表格，命令如下：</p><pre class="crayon-plain-tag">crontab -e</pre><p>如果你是第一次编辑这个，他会让你选择文件打开方式，随便选一个数字就好了。</p>
<p>比如我们用GNU打开的，我们就在它的最后一行添加下面的一句话即可。</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/08/20150816165506.jpg"><img class="alignnone size-full wp-image-1984" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/08/20150816165506.jpg" alt="20150816165506" width="640" height="384" /></a>、</p>
<p>文字版本：</p><pre class="crayon-plain-tag">*/5 * * * * /etc/mysql/mysql_listen.sh</pre><p>/5代表五分钟执行一次，后面的四个点依次代表了，小时，日，月，星期。如果想要时间长一些，比如一小时调度一次，那就设置一下后面第一个*就好了。</p>
<p>好，保存一下，重启cron服务。</p><pre class="crayon-plain-tag">service cron restart</pre><p>嗯，调度任务已经添加进去了，这样，每五分钟系统就会调用一下刚才写的那个脚本。</p>
<p>过一段时间，我们来看一下运行效果，嗯，监控跑的很顺利呐。</p>
<p><a href="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/08/20150816165858.jpg"><img class="alignnone size-full wp-image-1985" src="http://qiniu.cuiqingcai.com/wp-content/uploads/2015/08/20150816165858.jpg" alt="20150816165858" width="496" height="261" /></a></p>
<p>文字版本：</p><pre class="crayon-plain-tag">Sun Aug 16 15:39:12 CST 2015 mysql running
Sun Aug 16 15:40:01 CST 2015 mysql running
Sun Aug 16 15:45:02 CST 2015 mysql running
Sun Aug 16 15:50:01 CST 2015 mysql running
Sun Aug 16 15:55:01 CST 2015 mysql running
Sun Aug 16 16:00:01 CST 2015 mysql running
Sun Aug 16 16:05:01 CST 2015 mysql running
Sun Aug 16 16:10:01 CST 2015 mysql running
Sun Aug 16 16:15:01 CST 2015 mysql running
Sun Aug 16 16:20:01 CST 2015 mysql running
Sun Aug 16 16:25:01 CST 2015 mysql running
Sun Aug 16 16:30:01 CST 2015 mysql running
Sun Aug 16 16:35:01 CST 2015 mysql running
Sun Aug 16 16:40:01 CST 2015 mysql running
Sun Aug 16 16:51:04 CST 2015 mysql running</pre><p>哈哈，是不是五分钟监测了一次呢？大功告成。</p>
<h2>后记</h2>
<p>这样，我们就实现了五分钟定时检测MySQL进程服务，妈妈再也不用担心我的网站会宕掉啦。</p>
<p>如有问题，欢迎留言交流，谢谢啦。</p>
<p>转载请注明：<a href="http://blog.cuiqingcai.com">静觅</a> &raquo; <a href="http://blog.cuiqingcai.com/1981.html">Ubuntu Linux下定时监测MySQL进程终止时自动重启的方法</a></p>]]></content:encoded>
			<wfw:commentRss>http://blog.cuiqingcai.com/1981.html/feed</wfw:commentRss>
		<slash:comments>3</slash:comments>
		</item>
		<item>
		<title>C语言小知识点练习总结</title>
		<link>http://blog.cuiqingcai.com/1934.html</link>
		<comments>http://blog.cuiqingcai.com/1934.html#comments</comments>
		<pubDate>Sat, 18 Jul 2015 13:52:01 +0000</pubDate>
		<dc:creator><![CDATA[崔庆才]]></dc:creator>
				<category><![CDATA[C/C++]]></category>

		<guid isPermaLink="false">http://cuiqingcai.com/?p=1934</guid>
		<description><![CDATA[最近在准备C语言的上级考试，之前对C接触不多，在练习过程中把一些小知识点记录下来。 1.字符串的截取 利用st [&#8230;]]]></description>
				<content:encoded><![CDATA[<p>最近在准备C语言的上级考试，之前对C接触不多，在练习过程中把一些小知识点记录下来。</p>
<h2>1.字符串的截取</h2>
<p>利用strncpy函数，传入三个参数，分别为目标字符串，起始位置，长度。</p>
<p>例如将日期字符串转化为数字，如20120112</p><pre class="crayon-plain-tag">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main() {

    char date1[20],date2[20];
    scanf("%s",&amp;date1);
    scanf("%s",&amp;date2);
    char temp[4];
    int year1 = atoi(strncpy(temp,date1,4));
    int year2 = atoi(strncpy(temp,date2,4));
    printf("year1:%d\n",year1);
    printf("year2:%d\n",year2);
    char temp2[2];
    int month1 = atoi(strncpy(temp2,date1+4,2));
    int month2 = atoi(strncpy(temp2,date2+4,2));
    printf("month1:%d\n",month1);
    printf("month2:%d\n",month2);
    int day1 = atoi(strncpy(temp2,date1+6,2));
    int day2 = atoi(strncpy(temp2,date2+6,2));
    printf("day1:%d\n",day1);
    printf("day2:%d\n",day2);
    return 0;

}</pre><p>以上便实现了输入一个日期然后对其进行分割的操作。</p>
<h2>2.二维数组的动态声明</h2>
<p>利用malloc可以实现数组的动态声明</p><pre class="crayon-plain-tag">int **a;
    a = (int **)malloc(2*sizeof(int *));
    int i,j;
    for (i = 0; i &lt; 2; i ++) {
        a[i] = (int *)malloc(3*sizeof(int));
        for (j = 0; j &lt; 3; j++) {
            scanf("%d",&amp;a[i][j]);
        }
    }</pre><p>以上便实现了动态数组的分配，利用scanf为数组赋值</p>
<h2>3.二维数组的声明和初始化</h2>
<p>头文件</p><pre class="crayon-plain-tag">#include &lt;memory.h&gt;</pre><p>初始化和测试</p><pre class="crayon-plain-tag">int result[2][2];
    for (i = 0; i &lt; 2; i ++) {
        for (j = 0; j &lt; 2; j++) {
            printf("%d ",result[i][j]);
        }
        printf("\n");
    }
    memset(result,0,sizeof(int)*4);
    for (i = 0; i &lt; 2; i ++) {
        for (j = 0; j &lt; 2; j++) {
            printf("%d ",result[i][j]);
        }
        printf("\n");
    }</pre><p>结果</p><pre class="crayon-plain-tag">4196944 0 
4195696 0 
0 0 
0 0</pre><p>上述是数组的非动态声明</p>
<h2>4.快速排序</h2>
<p>假设要排序的数组是A[1]……A[N]，首先任意选取一个数据（通常选用第一个数据）作为关键数据，然后将所有比它的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。一趟快速排序的算法是：</p>
<p>1）设置两个变量I、J，排序开始的时候 I=0，J=N-1；</p>
<p>2）以第一个数组元素作为关键数据，赋值给X，即X=A[0]；</p>
<p>3）从J开始向前搜索，即由后开始向前搜索，找到第一个小于X的值，两者交换；</p>
<p>4）从I开始向后搜索，即由前开始向后搜索，找到第一个大于X的值，两者交换；</p>
<p>5）重复第3、4步，直到I=J；</p>
<p>例如：待排序的数组A的值分别是：（初始关键数据X：=49）</p>
<p>A[0] A[1] A[2] A[3] A[4] A[5] A[6]<br />
49 38 65 97 76 13 27</p>
<p>进行第一次交换后： 27 38 65 97 76 13 49<br />
( 按照算法的第三步从后面开始找 ）</p>
<p>进行第二次交换后： 27 38 49 97 76 13 65<br />
( 按照算法的第四步从前面开始找&gt;X的值，65&gt;49,两者交换，此时I=3 )</p>
<p>进行第三次交换后： 27 38 13 97 76 49 65<br />
( 按照算法的第五步将又一次执行算法的第三步从后开始找）</p>
<p>进行第四次交换后： 27 38 13 49 76 97 65<br />
( 按照算法的第四步从前面开始找大于X的值，97&gt;49,两者交换，此时J=4 )</p>
<p>此时再执行第三不的时候就发现I=J，从而结束一躺快速排序，那么经过一躺快速排序之后：<br />
27 38 13 49 76 97 65<br />
即所有大于49的数全部在49的后面，所有小于49的数全部在49的前面。</p><pre class="crayon-plain-tag">#include &lt;stdio.h&gt;

void quiksort(int a[],int low,int high)
{
    int i = low;
    int j = high;  
    int temp = a[i]; 
  
    if( low &lt; high)
    {          
        while(i &lt; j) 
        {
            while((a[j] &gt;= temp) &amp;&amp; (i &lt; j))
            { 
                j--; 
            }
            a[i] = a[j];
            while((a[i] &lt;= temp) &amp;&amp; (i &lt; j))
            {
                i++; 
            }  
            a[j]= a[i];
        }
        a[i] = temp;
        quiksort(a,low,i-1);
        quiksort(a,j+1,high);
    }
    else
    {
        return;
    }
}
 
int main()
{
    int arr[5] = {23,1,21,4,19};
    quiksort(arr,0,4);
    int i;
    for(i=0;i&lt;5;i++)
    {
        printf("%d ",arr[i]);
    }
    printf("\n");
    return 0;
}</pre><p>快速排序代码如上</p>
<h2>5.字符串拷贝</h2>
<p>小例子如下</p><pre class="crayon-plain-tag">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main(){
	char str[20] = "hello";
	char *a = "world";
	strcpy(str,a);
	printf("%s",str);
	printf("\n");
	system("pause");
	return 0;
}</pre><p>运行结果：world，即把后者完全覆盖前者。</p><pre class="crayon-plain-tag">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main(){
	char *str = new char[6];
	char *a = "world";
	strcpy(str,a);
	printf("%s", str);
	printf("\n");
	system("pause");
	return 0;
}</pre><p>运行结果一致</p>
<p>某一长度的字符串截取</p><pre class="crayon-plain-tag">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main(){
	char *str = new char[6];
	char *a = "world";
	strncpy(str,a+1,5);
	printf("%s", str);
	printf("\n");
	system("pause");
	return 0;
}</pre><p>运行结果：orld</p>
<h2>6.字符串的拼接</h2>
<p>小例子如下</p><pre class="crayon-plain-tag">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main(){
	char str[20] = "hello ";
	char *a = "world";
	char *x = strcat(str,a);
	printf("%s\n", x);
	printf("%s\n", x);
	printf("\n");
	system("pause");
	return 0;
}</pre><p>运行结果：</p>
<p>hello world</p>
<p>hello world</p>
<p>此函数既返回结果，又将目标字符串赋值</p>
<h2>7.字符串查找匹配</h2>
<p>例子如下</p><pre class="crayon-plain-tag">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main(){
	char str[20] = "hello ";
	char *x = strchr(str,'e');
	printf("%d\n", x - str);
	printf("%s\n",x);
	printf("\n");
	system("pause");
	return 0;
}</pre><p>运行结果：</p>
<p>1</p>
<p>ello</p>
<h2>8.字符串比较</h2>
<p>例子如下</p><pre class="crayon-plain-tag">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main(){
	char str[20] = "hello ";
	char str2[20] = "hello2";
	int x = strcmp(str, str2);
	printf("%d\n",x);
	printf("\n");
	system("pause");
	return 0;
}</pre><p>运行结果-1</p>
<p>忽略大小写</p><pre class="crayon-plain-tag">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main(){
	char str[20] = "hello";
	char str2[20] = "Hello";
	int x = stricmp(str, str2);
	printf("%d\n",x);
	printf("\n");
	system("pause");
	return 0;
}</pre><p>运行结果0</p>
<h2>9.字符串分割</h2>
<p>示例如下</p><pre class="crayon-plain-tag">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main() 
{
      char test1[] = "feng,ke,wei";  
	  char x[3][30];
      char *p;  
      p = strtok(test1, ",");
	  int count = 0;
      while (p) {   
		printf("%s\n", p);   
		strcpy(x[count],p);
		count++;
		p = strtok(NULL, ",");     
      }    
	  for (int i = 0; i&lt;count; i ++) {
		printf("%s ", x[i]);
	  }
	  system("pause");
      return 0;
 }</pre><p>运行结果</p>
<p>feng<br />
ke<br />
wei<br />
feng ke wei</p>
<h2>10.格式化输出几位小数</h2>
<p>例如</p><pre class="crayon-plain-tag">printf("%.5f",18.223);</pre><p>则是输出5位小数</p>
<p>又如</p><pre class="crayon-plain-tag">printf("%5.1f",1.2345);</pre><p>则是控制总位数为5，小数点后为1位，不够的在前面补空格</p>
<p>转载请注明：<a href="http://blog.cuiqingcai.com">静觅</a> &raquo; <a href="http://blog.cuiqingcai.com/1934.html">C语言小知识点练习总结</a></p>]]></content:encoded>
			<wfw:commentRss>http://blog.cuiqingcai.com/1934.html/feed</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>Winpcap网络编程六之两台主机通过中间主机通信</title>
		<link>http://blog.cuiqingcai.com/1922.html</link>
		<comments>http://blog.cuiqingcai.com/1922.html#comments</comments>
		<pubDate>Sun, 12 Jul 2015 17:19:22 +0000</pubDate>
		<dc:creator><![CDATA[崔庆才]]></dc:creator>
				<category><![CDATA[C/C++]]></category>
		<category><![CDATA[Winpcap]]></category>

		<guid isPermaLink="false">http://cuiqingcai.com/?p=1922</guid>
		<description><![CDATA[本节任务 本次我们需要完成的任务是 完成两台主机通过中间主机的数据通信（网络层）  增加基于IP地址的转发功能 [&#8230;]]]></description>
				<content:encoded><![CDATA[<h2>本节任务</h2>
<p>本次我们需要完成的任务是</p>
<p>完成两台主机通过中间主机的数据通信（网络层）</p>
<ul>
<li> 增加基于IP地址的转发功能</li>
<li> 增加网络层封装</li>
</ul>
<p>其实最主要的就是基于IP地址的转发功能，网络层的封装其实我们在初级功能中就已经做好了。</p>
<h2>原理</h2>
<p>首先，实验的思路是A通过中间主机B向C发送数据。那么B则作为一个路由器，B要监听两个网卡，一个网卡发来的数据通过另一个网卡发出去。</p>
<p>示意图如下：</p>
<p>A&#8212;&#8212;&#8212;&gt;B1===B2&#8212;&#8212;&#8212;&#8212;&gt;C</p>
<p>从图上可以看出，B主机的两个网卡数据互通，A和B1则处于一个局域网内，B2和C处于另一个局域网内。</p>
<p>就比如这样，现在室友A在用有线上网，我的电脑B也在用有线上网，我们的有线处在同一局域网，我的电脑B同时散着一个无线网，我的手机C又连接到了这个无线上。</p>
<p>那么要实现A到C的数据传送，即模拟室友A要发送数据到我的手机C，那么流程则是这样的：</p>
<p>室友A在有线局域网发送数据到我的网卡B1，B1将数据通过网卡B2转发到无线局域网，通过无线局域网到达我的手机C。</p>
<p>A的发送要构建一个帧，目的MAC地址为B1,目的IP为C。B则要开启两个网卡，B1监听接收数据，B2网卡则要用ARP协议扫描所在无线局域网内的IP和MAC,B获取到了A发来的帧之后，解析它的IP地址和MAC地址，匹配刚才扫描得到的IP和MAC对应表，将源MAC换成B2网卡MAC，目的MAC换成C的MAC，IP不变，数据data不变。构建新帧之后发送出去。</p>
<p>好啦，思路大体就是这样。</p>
<h2>实战</h2>
<p>需要三个程序，一个是发送，一个路由，一个接收。所以一共三个程序要同时运行起来执行。</p>
<p>以上是我的大体思路，如有错误，还请指正。现已用代码实现完毕。</p>
<p>代码暂不公开，只提供部分重点代码解析：</p>
<h3>一、发送端</h3>
<p>其实发送端和初级功能的发送差不多</p>
<p>个人编写的交互流程如下：</p><pre class="crayon-plain-tag">IP地址:121.250.216.221   MAC地址:3c970e4b56d6con:127

-------------------------------------------
IP地址:121.250.216.227   MAC地址:089e01b948f4con:128

-------------------------------------------
IP地址:121.250.216.228   MAC地址:10bf48705aeecon:129

获取MAC地址完毕,请输入你要发送对方的IP地址:
192.168.1.3
请输入你要发送的内容:
im cqc
要发送的内容:im cqc</pre><p>具体代码不再解析，同上一篇初级功能。</p>
<h3>二、路由端</h3>
<p>首先要开启两个网卡，声明两个网卡对象和处理器</p><pre class="crayon-plain-tag">pcap_if_t  *d,*d2;					//选中的网络适配器
pcap_t *adhandle,*adhandle2;           //捕捉实例,是pcap_open返回的对象,adhandle是用来发送数据，adhandle2是用来接收数据</pre><p>一个用来接收一个用来发送，这里定义了adhandle是用来发送，adhandle2是用来接收数据。</p>
<p>那么打开适配器就在main方法中，提前打开两个网卡</p><pre class="crayon-plain-tag">int num;
	printf("请输入你要转发数据的网卡代号:\n");
	//让用户选择选择哪个适配器进行转发
	scanf_s("%d",&amp;num);

	//跳转到选中的适配器
	for(d=alldevs, i=0; i&lt; num-1 ; d=d-&gt;next, i++);

	//运行到此处说明用户的输入是合法的，找到发送数据网卡
	if((adhandle = pcap_open(d-&gt;name,		//设备名称
													65535,       //存放数据包的内容长度
													PCAP_OPENFLAG_PROMISCUOUS,  //混杂模式
													1000,           //超时时间
													NULL,          //远程验证
													errbuf         //错误缓冲
													)) == NULL){
    //打开适配器失败,打印错误并释放适配器列表
	fprintf(stderr,"\nUnable to open the adapter. %s is not supported by WinPcap\n", d-&gt;name);
    // 释放设备列表 
    pcap_freealldevs(alldevs);
    return -1;
	}

	int num2;
	printf("请输入你要接收数据的网卡代号:");
	//让用户选择用哪个网卡来收数据
	scanf_s("%d",&amp;num2);
	//用户输入的数字超出合理范围


	//跳转到选中的适配器
	for(d2=alldevs, i=0; i&lt; num2-1 ; d2=d2-&gt;next, i++);

	//运行到此处说明用户的输入是合法的
	if((adhandle2 = pcap_open(d2-&gt;name,		//设备名称
													65535,       //存放数据包的内容长度
													PCAP_OPENFLAG_PROMISCUOUS,  //混杂模式
													1000,           //超时时间
													NULL,          //远程验证
													errbuf         //错误缓冲
													)) == NULL){
    //打开适配器失败,打印错误并释放适配器列表
	fprintf(stderr,"\nUnable to open the adapter. %s is not supported by WinPcap\n", d2-&gt;name);</pre><p>接下来用用于发送的handle处理器来扫描它的局域网IP，获得局域网内的MAC地址，记录在一个表中,存放IP和MAC的对应关系。</p>
<p>这个表可以用结构体数组来保存，比如可以这样:</p><pre class="crayon-plain-tag">struct ip_mac_list{
	IpAddress ip;
	unsigned char mac[6];
};</pre><p></p><pre class="crayon-plain-tag">ip_mac_list  list[256];                       //存储IP和MAC地址的对应表</pre><p>那么以上便是准备工作，我们完成了两个网卡的打开，发送网卡扫描获取局域网MAC，接下来便是最重要的监听加转发。</p>
<p>那么这个怎办？那就开一个新线程。</p>
<p>让我们声明一个新的路由线程。</p><pre class="crayon-plain-tag">DWORD WINAPI RouteThread(LPVOID lpParameter);</pre><p>那么线程要接收进来什么参数呢？</p>
<p>首先必须要的是两个网卡处理器，在main方法中已经做好初始化的adhandle和adhandle2，另外还有alldevs，可以持有这个指针来释放设备列表，出现错误时释放资源并退出。</p>
<p>初级功能中声明过了</p>
<p>struct sparam sp;<br />
struct gparam gp;</p>
<p>这两个就是发送ARP线程和接收ARP线程中的两个参数，那么仿照这个功能，我们定义一个新的结构体</p><pre class="crayon-plain-tag">struct rparam{
	pcap_t *adhandle_rec;
	pcap_t *adhandle_send;
	pcap_if_t  * alldevs;       //所有网络适配器
};</pre><p>在main方法中把它来初始化赋值</p><pre class="crayon-plain-tag">rp.adhandle_send = adhandle;
	rp.adhandle_rec = adhandle2;
	rp.alldevs = alldevs;</pre><p>当做参数传入这个线程</p><pre class="crayon-plain-tag">routethread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) RouteThread, &amp;rp,
			0, NULL);</pre><p>其中第四个参数就是传递了这个结构体进去。注意这个语句最好不要直接放在main方法中直接调用，可以在全部获取完MAC地址之后再开启这个线程。</p>
<p>那么接下来就说一下这个线程都干了些什么，只简略说一下核心部分。</p>
<p>首先开启了这个线程之后会一直都在执行，那么就可以加入</p><pre class="crayon-plain-tag">while((res = pcap_next_ex(adhandle2,&amp;header,&amp;pkt_data))&gt;=0)</pre><p>这样的while判断语句来一直监听数据包的接收，然后解析数据。</p><pre class="crayon-plain-tag">ethernet =  (EthernetHeader *)(pkt_data);
			for(int i=0;i&lt;6;i++){
				sou_mac[i] = ethernet-&gt;SourMAC[i];
			}
			for(int i=0;i&lt;6;i++){
				des_mac[i] = ethernet-&gt;DestMAC[i];
			}
			// 获得IP数据包头部的位置
			ip = (IpHeader *) (pkt_data +14);    //14为以太网帧头部长度
			//获得TCP头部的位置
			ip_len = (ip-&gt;Version_HLen &amp; 0xf) *4;
			tcp = (TcpHeader *)((u_char *)ip+ip_len);
			data = (char *)((u_char *)tcp+20);
			printf("data:%s\n",data);
			printf("ip:");
			printf("%d.%d.%d.%d -&gt; %d.%d.%d.%d\n",
					ip-&gt;SourceAddr.byte1,
					ip-&gt;SourceAddr.byte2,
					ip-&gt;SourceAddr.byte3,
					ip-&gt;SourceAddr.byte4,
				    ip-&gt;DestinationAddr.byte1,
				    ip-&gt;DestinationAddr.byte2,
				    ip-&gt;DestinationAddr.byte3,
				    ip-&gt;DestinationAddr.byte4);
			 printf("sou_mac:%02x-%02x-%02x-%02x-%02x-%02x\n", sou_mac[0], sou_mac[1], sou_mac[2],
			    sou_mac[3], sou_mac[4], sou_mac[5]);
			printf("des_mac:%02x-%02x-%02x-%02x-%02x-%02x\n", des_mac[0], des_mac[1], des_mac[2],
			    des_mac[3], des_mac[4], des_mac[5]);</pre><p>然后接下来每接收到一个数据，就进行构建新的帧转发出去，目的MAC先匹配list表，如果list没有找到，那么我让他指定了一个mac，比如广播MAC。源MAC地址则赋值网卡的MAC地址。<br />
注意，传统以太网中数据长度为45-1500，那么我在构建前把解析出的data作了下判断长度再构建，因为我已经把sendbuffer声明为一个固定长度了，为了防止越界，我先进行一个长度判断。</p><pre class="crayon-plain-tag">//以下开始构建帧发送
		//首先判断data最大值小于1500
		if(strlen(data)&lt;1500){
			//目的MAC
			BYTE send_destmac[6];
			bool findMac = false;
			for(int c = 0;c&lt;con;c++){
				if(ip-&gt;DestinationAddr.byte1 ==  list[c].ip.byte1&amp;&amp;
					ip-&gt;DestinationAddr.byte2 == list[c].ip.byte2&amp;&amp;
					ip-&gt;DestinationAddr.byte3 == list[c].ip.byte3&amp;&amp;
					ip-&gt;DestinationAddr.byte4 == list[c].ip.byte4)
				{
					printf("Find its MAC!\n");
					findMac = true;
					send_destmac[0] = list[c].mac[0];   
					send_destmac[1] = list[c].mac[1];
					send_destmac[2] = list[c].mac[2];
					send_destmac[3] = list[c].mac[3];
					send_destmac[4] = list[c].mac[4];
					send_destmac[5] = list[c].mac[5];
				}
			}
			if(!findMac){
				send_destmac[0] = 0xff;   
				send_destmac[1] = 0xff;   
				send_destmac[2] = 0xff;   
				send_destmac[3] = 0xff;   
				send_destmac[4] = 0xff;   
				send_destmac[5] = 0xff;   
			}
			printf("destmac:%02x-%02x-%02x-%02x-%02x-%02x\n",
				send_destmac[0],send_destmac[1],send_destmac[2],
				send_destmac[3],send_destmac[4],send_destmac[5]
				);
			memcpy(send_ethernet.DestMAC, send_destmac, 6);
			//源MAC地址
			BYTE send_hostmac[6];
			//源MAC地址
			send_hostmac[0] = local_mac[0];     //赋值本地MAC地址
			send_hostmac[1] = local_mac[1];
			send_hostmac[2] = local_mac[2];
			send_hostmac[3] = local_mac[3];
			send_hostmac[4] = local_mac[4];
			send_hostmac[5] = local_mac[5];
			//赋值源MAC地址
			memcpy(send_ethernet.SourMAC, send_hostmac, 6);
			send_ethernet.EthType = htons(0x0800);
			//赋值SendBuffer
			memcpy(&amp;SendBuffer, &amp;send_ethernet, sizeof(struct EthernetHeader));</pre><p>以上只是赋值了帧头，至于IP头，TCP头，数据的赋值就参照初级功能的来赋值吧，不要忘了校验和的检验。好，大体上就是这样，接受来数据包并转发出去的原理就是这样。</p>
<h3>三、接收</h3>
<p>不用多改，就是初级功能中的接收，在此写一写小小的优化措施，防止接收到过多的数据帧而造成不断乱蹦，导致你看不到接收的东西。</p>
<p>在打印的时候加一个过滤就好了。部分代码如下：</p>
<p>在main方法中提示用户输入要接收的IP地址</p><pre class="crayon-plain-tag">printf("请输入要接收的IP地址,输入0.0.0.0代表全部接收,请输入\n");
	bool receiveAll = false;
	u_int ip1,ip2,ip3,ip4;
	bool legal = false;
	while(!legal){
		scanf_s("%d.%d.%d.%d",&amp;ip1,&amp;ip2,&amp;ip3,&amp;ip4);
		if(ip1==0&amp;&amp;ip2==0&amp;&amp;ip3==0&amp;&amp;ip4==0){
			receiveAll = true;
			legal = true;
			break;
		}
		if(ip1&lt;0||ip1&gt;255||ip2&lt;0||ip2&gt;255||ip3&lt;0||ip3&gt;255||ip4&lt;1||ip4&gt;254){
			legal = false;
			printf("对不起,IP输入不合法,请重新输入:\n");
		}else{
			legal = true;
		}
	}</pre><p>打印时的判断</p><pre class="crayon-plain-tag">if(receiveAll||(ip-&gt;SourceAddr.byte1==ip1&amp;&amp;
					ip-&gt;SourceAddr.byte2==ip2&amp;&amp;
					ip-&gt;SourceAddr.byte3==ip3&amp;&amp;
					ip-&gt;SourceAddr.byte4==ip4)){
					printf("%d.%d.%d.%d.%d -&gt; %d.%d.%d.%d.%d\n",
					ip-&gt;SourceAddr.byte1,
					ip-&gt;SourceAddr.byte2,
					ip-&gt;SourceAddr.byte3,
					ip-&gt;SourceAddr.byte4,
				    sport,
				    ip-&gt;DestinationAddr.byte1,
				    ip-&gt;DestinationAddr.byte2,
				    ip-&gt;DestinationAddr.byte3,
				    ip-&gt;DestinationAddr.byte4,
				    dport);
			    printf("sou_mac:%02x-%02x-%02x-%02x-%02x-%02x\n", sou_mac[0], sou_mac[1], sou_mac[2],
			    sou_mac[3], sou_mac[4], sou_mac[5]);
				printf("des_mac:%02x-%02x-%02x-%02x-%02x-%02x\n", des_mac[0], des_mac[1], des_mac[2],
			    des_mac[3], des_mac[4], des_mac[5]);
				printf("%s\n",data);
				printf("-----------------------------------------------------\n");
			}</pre><p>好，代码就先放送这么多，具体的实现只要有了思路我相信肯定不难，如有问题，欢迎与我交流。</p>
<p>转载请注明：<a href="http://blog.cuiqingcai.com">静觅</a> &raquo; <a href="http://blog.cuiqingcai.com/1922.html">Winpcap网络编程六之两台主机通过中间主机通信</a></p>]]></content:encoded>
			<wfw:commentRss>http://blog.cuiqingcai.com/1922.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Winpcap网络编程五之ARP协议获得MAC表及主机通信</title>
		<link>http://blog.cuiqingcai.com/1918.html</link>
		<comments>http://blog.cuiqingcai.com/1918.html#comments</comments>
		<pubDate>Sun, 12 Jul 2015 17:14:21 +0000</pubDate>
		<dc:creator><![CDATA[崔庆才]]></dc:creator>
				<category><![CDATA[C/C++]]></category>
		<category><![CDATA[Winpcap]]></category>

		<guid isPermaLink="false">http://cuiqingcai.com/?p=1918</guid>
		<description><![CDATA[学习文档 这里我们直接进入正题吧，关于Winpcap的基础知识讲解这里就不再赘述了。在这里给大家提供一些学习网 [&#8230;]]]></description>
				<content:encoded><![CDATA[<h2>学习文档</h2>
<p>这里我们直接进入正题吧，关于Winpcap的基础知识讲解这里就不再赘述了。在这里给大家提供一些学习网址</p>
<p><a class="dl link" href="http://blog.csdn.net/column/details/winpcap.html" target="_blank">Winpcap网络编程及通信教程</a><a class="dl link"  href="http://www.ferrisxu.com/WinPcap/html/" target="_blank">Winpcap中文技术文档</a></p>
<h2>学习内容</h2>
<ul>
<li>获取设备列表</li>
<li>获取已安装设备的高级信息</li>
<li>打开适配器并捕获数据包</li>
<li>不用回调方法捕获数据包</li>
<li>过滤数据包</li>
<li>分析数据包</li>
<li>处理脱机堆文件</li>
<li>发送数据包</li>
<li>收集并统计网络流量</li>
</ul>
<p>这些内容，在上述两个链接中均已经有了比较详细的讲解，希望对大家有帮助。</p>
<h2>两台主机通信实战</h2>
<p>完成两台主机之间的数据通信（数据链路层）</p>
<ul>
<li>仿真ARP协议获得网段内主机的MAC表</li>
<li>使用帧完成两台主机的通信（Hello! I’m …)</li>
</ul>
<p>首先我们要理解ARP是干嘛的，ARP主要作用就是通过IP地址来获取MAC地址。那么怎样获取呢？本机向局域网内主机发送ARP包，ARP包内包含了目的IP，源IP，目的MAC，源MAC，其中目的MAC地址为广播地址,FF-FF-FF-FF-FF-FF,即向局域网内所有主机发送一个ARP请求，那么其他主机收到这个请求之后则会向请求来源返回一个数据包。在这个返回的数据包中包含了自身的MAC地址。那么本机收到这些返回的数据包进行解析之后便会得到局域网内所有主机的MAC地址了..</p>
<p>编程开始：</p>
<p>新建一个C++项目，配好环境，引入Winpcap相关的库，这些不再赘述。</p>
<p>头文件引入</p><pre class="crayon-plain-tag">#define HAVE_REMOTE
#define WPCAP
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pcap.h&gt;</pre><p>在main函数中首先声明一系列变量如下</p><pre class="crayon-plain-tag">char *ip_addr;                                    //IP地址
	char *ip_netmask;                             //子网掩码
	unsigned char *ip_mac;          //本机MAC地址</pre><p>为这三个变量分配地址空间</p><pre class="crayon-plain-tag">ip_addr = (char *) malloc(sizeof(char) * 16); //申请内存存放IP地址
	if (ip_addr == NULL)
	{
		printf("申请内存存放IP地址失败!\n");
		return -1;
	}
	ip_netmask = (char *) malloc(sizeof(char) * 16); //申请内存存放NETMASK地址
	if (ip_netmask == NULL)
	{
		printf("申请内存存放NETMASK地址失败!\n");
		return -1;
	}
	ip_mac = (unsigned char *) malloc(sizeof(unsigned char) * 6); //申请内存存放MAC地址
	if (ip_mac == NULL)
	{
		printf("申请内存存放MAC地址失败!\n");
		return -1;
	}</pre><p>接下来就是烂大街的程序,获取适配器列表并选中相应的适配器,注释已经在代码中了,如果还有不明白的请参照前几次的讲解。</p><pre class="crayon-plain-tag">//获取本地适配器列表
	if(pcap_findalldevs_ex(PCAP_SRC_IF_STRING,NULL,&amp;alldevs,errbuf) == -1){
		//结果为-1代表出现获取适配器列表失败
		fprintf(stderr,"Error in pcap_findalldevs_ex:\n",errbuf);
		//exit(0)代表正常退出,exit(other)为非正常退出,这个值会传给操作系统
		exit(1);
	}
	

	for(d = alldevs;d !=NULL;d = d-&gt;next){
		printf("-----------------------------------------------------------------\nnumber:%d\nname:%s\n",++i,d-&gt;name);
		if(d-&gt;description){
			//打印适配器的描述信息
			printf("description:%s\n",d-&gt;description);
		}else{
			//适配器不存在描述信息
			printf("description:%s","no description\n");
		}
		//打印本地环回地址
		 printf("\tLoopback: %s\n",(d-&gt;flags &amp; PCAP_IF_LOOPBACK)?"yes":"no");
		 /**
		 pcap_addr *  next     指向下一个地址的指针
		 sockaddr *  addr       IP地址
		 sockaddr *  netmask  子网掩码
		 sockaddr *  broadaddr   广播地址
		 sockaddr *  dstaddr        目的地址
		 */
		 pcap_addr_t *a;       //网络适配器的地址用来存储变量
		 for(a = d-&gt;addresses;a;a = a-&gt;next){
			 //sa_family代表了地址的类型,是IPV4地址类型还是IPV6地址类型
			 switch (a-&gt;addr-&gt;sa_family)
			 {
				 case AF_INET:  //代表IPV4类型地址
					 printf("Address Family Name:AF_INET\n");
					 if(a-&gt;addr){
						 //-&gt;的优先级等同于括号,高于强制类型转换,因为addr为sockaddr类型，对其进行操作须转换为sockaddr_in类型
						 printf("Address:%s\n",iptos(((struct sockaddr_in *)a-&gt;addr)-&gt;sin_addr.s_addr));
					 }
					if (a-&gt;netmask){
						 printf("\tNetmask: %s\n",iptos(((struct sockaddr_in *)a-&gt;netmask)-&gt;sin_addr.s_addr));
					}
					if (a-&gt;broadaddr){
						   printf("\tBroadcast Address: %s\n",iptos(((struct sockaddr_in *)a-&gt;broadaddr)-&gt;sin_addr.s_addr));
					 }
					 if (a-&gt;dstaddr){
						   printf("\tDestination Address: %s\n",iptos(((struct sockaddr_in *)a-&gt;dstaddr)-&gt;sin_addr.s_addr));
					 }
        			 break;
				 case AF_INET6: //代表IPV6类型地址
					 printf("Address Family Name:AF_INET6\n");
					 printf("this is an IPV6 address\n");
					 break;
				 default:
					 break;
			 }
		 }
	}
	//i为0代表上述循环未进入,即没有找到适配器,可能的原因为Winpcap没有安装导致未扫描到
	if(i == 0){
		printf("interface not found,please check winpcap installation");
	}

	int num;
	printf("Enter the interface number(1-%d):",i);
	//让用户选择选择哪个适配器进行抓包
	scanf_s("%d",&amp;num);
	printf("\n");

	//用户输入的数字超出合理范围
	if(num&lt;1||num&gt;i){
		printf("number out of range\n");
		pcap_freealldevs(alldevs);
		return -1;
	}
	//跳转到选中的适配器
	for(d=alldevs, i=0; i&lt; num-1 ; d=d-&gt;next, i++);

	//运行到此处说明用户的输入是合法的
	if((adhandle = pcap_open(d-&gt;name,		//设备名称
														65535,       //存放数据包的内容长度
														PCAP_OPENFLAG_PROMISCUOUS,  //混杂模式
														1000,           //超时时间
														NULL,          //远程验证
														errbuf         //错误缓冲
														)) == NULL){
        //打开适配器失败,打印错误并释放适配器列表
		fprintf(stderr,"\nUnable to open the adapter. %s is not supported by WinPcap\n", d-&gt;name);
        // 释放设备列表 
        pcap_freealldevs(alldevs);
        return -1;
	}</pre><p>上述代码中需要另外声明的有：</p><pre class="crayon-plain-tag">pcap_if_t  * alldevs;       //所有网络适配器
	pcap_if_t  *d;					//选中的网络适配器
	char errbuf[PCAP_ERRBUF_SIZE];   //错误缓冲区,大小为256
	pcap_t *adhandle;           //捕捉实例,是pcap_open返回的对象
	int i = 0;                            //适配器计数变量</pre><p></p><pre class="crayon-plain-tag">char *iptos(u_long in);       //u_long即为 unsigned long</pre><p></p><pre class="crayon-plain-tag">/* 将数字类型的IP地址转换成字符串类型的 */
#define IPTOSBUFFERS    12
char *iptos(u_long in)
{
    static char output[IPTOSBUFFERS][3*4+3+1];
    static short which;
    u_char *p;

    p = (u_char *)&amp;in;
    which = (which + 1 == IPTOSBUFFERS ? 0 : which + 1);
    sprintf_s(output[which], "%d.%d.%d.%d", p[0], p[1], p[2], p[3]);
    return output[which];
}</pre><p>到此程序应该会编译通过，可以试着编译一下运行。</p>
<p>GO ON&#8230;</p>
<p>接下来我们首先要用ifget方法获取自身的IP和子网掩码</p>
<p>函数声明：</p><pre class="crayon-plain-tag">void ifget(pcap_if_t *d, char *ip_addr, char *ip_netmask);</pre><p></p><pre class="crayon-plain-tag">//获取IP和子网掩码赋值为ip_addr和ip_netmask
void ifget(pcap_if_t *d, char *ip_addr, char *ip_netmask) {
	pcap_addr_t *a;
	//遍历所有的地址,a代表一个pcap_addr
	for (a = d-&gt;addresses; a; a = a-&gt;next) {
		switch (a-&gt;addr-&gt;sa_family) {
		case AF_INET:  //sa_family ：是2字节的地址家族，一般都是“AF_xxx”的形式。通常用的都是AF_INET。代表IPV4
			if (a-&gt;addr) {
				char *ipstr;
				//将地址转化为字符串
				ipstr = iptos(((struct sockaddr_in *) a-&gt;addr)-&gt;sin_addr.s_addr); //*ip_addr
				printf("ipstr:%s\n",ipstr);
				memcpy(ip_addr, ipstr, 16);
			}
			if (a-&gt;netmask) {
				char *netmaskstr;
				netmaskstr = iptos(((struct sockaddr_in *) a-&gt;netmask)-&gt;sin_addr.s_addr);
				printf("netmask:%s\n",netmaskstr);
				memcpy(ip_netmask, netmaskstr, 16);
			}
		case AF_INET6:
			break;
		}
	}
}</pre><p>main函数继续写，如下调用，之前声明的ip_addr和ip_netmask就已经被赋值了</p><pre class="crayon-plain-tag">ifget(d, ip_addr, ip_netmask); //获取所选网卡的基本信息--掩码--IP地址</pre><p>到现在我们已经获取到了本机的IP和子网掩码，下一步发送一个ARP请求来获取自身的MAC地址</p>
<p>这个ARP请求的源IP地址就随便指定了，就相当于你构造了一个外来的ARP请求，本机捕获到了请求，然后发送回应给对方的数据包也被本机捕获到了并解析出来了。解析了自己发出去的数据包而已。</p>
<p>那么我们就声明一个函数并实现：</p><pre class="crayon-plain-tag">int GetSelfMac(pcap_t *adhandle, const char *ip_addr, unsigned char *ip_mac);</pre><p></p><pre class="crayon-plain-tag">// 获取自己主机的MAC地址
int GetSelfMac(pcap_t *adhandle, const char *ip_addr, unsigned char *ip_mac) {
	unsigned char sendbuf[42]; //arp包结构大小
	int i = -1;
	int res;
	EthernetHeader eh; //以太网帧头
	Arpheader ah;  //ARP帧头
	struct pcap_pkthdr * pkt_header;
	const u_char * pkt_data;
	//将已开辟内存空间 eh.dest_mac_add 的首 6个字节的值设为值 0xff。
	memset(eh.DestMAC, 0xff, 6); //目的地址为全为广播地址
	memset(eh.SourMAC, 0x0f, 6);
	memset(ah.DestMacAdd, 0x0f, 6);
	memset(ah.SourceMacAdd, 0x00, 6);
	//htons将一个无符号短整型的主机数值转换为网络字节顺序
	eh.EthType = htons(ETH_ARP);
	ah.HardwareType= htons(ARP_HARDWARE);
	ah.ProtocolType = htons(ETH_IP);
	ah.HardwareAddLen = 6;
	ah.ProtocolAddLen = 4;
	ah.SourceIpAdd = inet_addr("100.100.100.100"); //随便设的请求方ip
	ah.OperationField = htons(ARP_REQUEST);
	ah.DestIpAdd = inet_addr(ip_addr);
	memset(sendbuf, 0, sizeof(sendbuf));
	memcpy(sendbuf, &amp;eh, sizeof(eh));
	memcpy(sendbuf + sizeof(eh), &amp;ah, sizeof(ah));
	printf("%s",sendbuf);
	if (pcap_sendpacket(adhandle, sendbuf, 42) == 0) {
		printf("\nPacketSend succeed\n");
	} else {
		printf("PacketSendPacket in getmine Error: %d\n", GetLastError());
		return 0;
	}
	//从interface或离线记录文件获取一个报文
	//pcap_next_ex(pcap_t* p,struct pcap_pkthdr** pkt_header,const u_char** pkt_data)
	while ((res = pcap_next_ex(adhandle, &amp;pkt_header, &amp;pkt_data)) &gt;= 0) {
		if (*(unsigned short *) (pkt_data + 12) == htons(ETH_ARP)
				&amp;&amp; *(unsigned short*) (pkt_data + 20) == htons(ARP_REPLY)
				&amp;&amp; *(unsigned long*) (pkt_data + 38)
						== inet_addr("100.100.100.100")) {
			for (i = 0; i &lt; 6; i++) {
				ip_mac[i] = *(unsigned char *) (pkt_data + 22 + i);
			}
			printf("获取自己主机的MAC地址成功!\n");
			break;
		}
	}
	if (i == 6) {
		return 1;
	} else {
		return 0;
	}
}</pre><p>其中我们需要定义一下常量如下</p><pre class="crayon-plain-tag">#define ETH_ARP         0x0806  //以太网帧类型表示后面数据的类型，对于ARP请求或应答来说，该字段的值为x0806
#define ARP_HARDWARE    1  //硬件类型字段值为表示以太网地址
#define ETH_IP          0x0800  //协议类型字段表示要映射的协议地址类型值为x0800表示IP地址
#define ARP_REQUEST     1   //ARP请求
#define ARP_REPLY       2      //ARP应答
#define HOSTNUM         255   //主机数量</pre><p>另外发送ARP请求少不了帧头和ARP头的结构，我们需要声明出来，另外我们构建发送包需要再声明两个结构体sparam和gparam</p><pre class="crayon-plain-tag">//帧头部结构体，共14字节
struct EthernetHeader
{
    u_char DestMAC[6];    //目的MAC地址 6字节
    u_char SourMAC[6];   //源MAC地址 6字节
    u_short EthType;         //上一层协议类型，如0x0800代表上一层是IP协议，0x0806为arp  2字节
};

//28字节ARP帧结构
struct Arpheader {
	unsigned short HardwareType; //硬件类型
	unsigned short ProtocolType; //协议类型
	unsigned char HardwareAddLen; //硬件地址长度
	unsigned char ProtocolAddLen; //协议地址长度
	unsigned short OperationField; //操作字段
	unsigned char SourceMacAdd[6]; //源mac地址
	unsigned long SourceIpAdd; //源ip地址
	unsigned char DestMacAdd[6]; //目的mac地址
	unsigned long DestIpAdd; //目的ip地址
};

//arp包结构
struct ArpPacket {
	EthernetHeader ed;
	Arpheader ah;
};

struct sparam {
	pcap_t *adhandle;
	char *ip;
	unsigned char *mac;
	char *netmask;
};
struct gparam {
	pcap_t *adhandle;
};

struct sparam sp;
struct gparam gp;</pre><p>到现在代码也是完整可以运行的，如果有问题请检查上述代码完整性和位置。</p>
<p>可能出现的BUG：</p>
<p>只显示ARP发送成功，没有接受到并解析打印。可能的原因是帧构造有问题，字节没有对齐，有偏差，像#define一样</p>
<p>写入如下代码：</p><pre class="crayon-plain-tag">#pragma pack(1)  //按一个字节内存对齐</pre><p>GO ON..</p>
<p>获取到了自身的MAC地址之后，就可以在本机上构建ARP广播请求，向局域网内的所有主机发送ARP请求，得到回应之后解析回应的数据包并进行解析，得到对方的MAC地址。在这里我们需要开启两个线程，一个用来发送一个用来接收。好，我们继续..</p>
<p>先声明两个线程</p><pre class="crayon-plain-tag">HANDLE sendthread;      //发送ARP包线程
	HANDLE recvthread;       //接受ARP包线程</pre><p>在main方法中继续写，对sp和gp两个ARP请求所需要的结构体进行赋值。赋值什么？就是你之前用ifget获取来的IP地址和子网掩码以及用getSelfMac获取来的MAC地址。</p><pre class="crayon-plain-tag">sp.adhandle = adhandle;
	sp.ip = ip_addr;
	sp.mac = ip_mac;
	sp.netmask = ip_netmask;
	gp.adhandle = adhandle;</pre><p>接下来直接创建两个线程，一个是发送一个接受，分别调用两个方法。</p><pre class="crayon-plain-tag">sendthread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) SendArpPacket,
			&amp;sp, 0, NULL);
	recvthread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) GetLivePC, &amp;gp,
			0, NULL);
	printf("\nlistening on 网卡%d ...\n", i);</pre><p>那么发送数据包的方法和接收解析数据包的方法怎样实现呢？</p>
<p>发送数据包，发送数据包先对结构体数据进行赋值，就像getSelfMac方法一样，然后声明了一个buffer用来存储每一个字节内容。</p>
<p>利用memset方法对buffer进行赋值。再利用一个for循环对255个主机进行发送，指定他们的IP地址。另外定义了一个flag,当发送成功之后将flag设置为1</p><pre class="crayon-plain-tag">/* 向局域网内所有可能的IP地址发送ARP请求包线程 */
DWORD WINAPI SendArpPacket(LPVOID lpParameter) //(pcap_t *adhandle,char *ip,unsigned char *mac,char *netmask)
{
	sparam *spara = (sparam *) lpParameter;
	pcap_t *adhandle = spara-&gt;adhandle;
	char *ip = spara-&gt;ip;
	unsigned char *mac = spara-&gt;mac;
	char *netmask = spara-&gt;netmask;
	printf("ip_mac:%02x-%02x-%02x-%02x-%02x-%02x\n", mac[0], mac[1], mac[2],
			mac[3], mac[4], mac[5]);
	printf("自身的IP地址为:%s\n", ip);
	printf("地址掩码NETMASK为:%s\n", netmask);
	printf("\n");
	unsigned char sendbuf[42]; //arp包结构大小
	EthernetHeader eh;
	Arpheader ah;
	//赋值MAC地址
	memset(eh.DestMAC, 0xff, 6);       //目的地址为全为广播地址
	memcpy(eh.SourMAC, mac, 6);
	memcpy(ah.SourceMacAdd, mac, 6);
	memset(ah.DestMacAdd, 0x00, 6);
	eh.EthType = htons(ETH_ARP);
	ah.HardwareType = htons(ARP_HARDWARE);
	ah.ProtocolType = htons(ETH_IP);
	ah.HardwareAddLen = 6;
	ah.ProtocolAddLen = 4;
	ah.SourceIpAdd = inet_addr(ip); //请求方的IP地址为自身的IP地址
	ah.OperationField = htons(ARP_REQUEST);
	//向局域网内广播发送arp包
	unsigned long myip = inet_addr(ip);
	unsigned long mynetmask = inet_addr(netmask);
	unsigned long hisip = htonl((myip &amp; mynetmask));
	//向255个主机发送
	for (int i = 0; i &lt; HOSTNUM; i++) {
		ah.DestIpAdd = htonl(hisip + i);
		//构造一个ARP请求
		memset(sendbuf, 0, sizeof(sendbuf));
		memcpy(sendbuf, &amp;eh, sizeof(eh));
		memcpy(sendbuf + sizeof(eh), &amp;ah, sizeof(ah));
		//如果发送成功
		if (pcap_sendpacket(adhandle, sendbuf, 42) == 0) {
			//printf("\nPacketSend succeed\n");
		} else {
			printf("PacketSendPacket in getmine Error: %d\n", GetLastError());
		}
		Sleep(50);
	}
	Sleep(1000);
	flag = TRUE;
	return 0;
}</pre><p>注: 此函数和flag变量在前面别忘了声明一下&#8230;</p>
<p>然后是接收数据包并打印MAC地址:</p><pre class="crayon-plain-tag">/* 分析截留的数据包获取活动的主机IP地址 */
DWORD WINAPI GetLivePC(LPVOID lpParameter) //(pcap_t *adhandle)
{
	gparam *gpara = (gparam *) lpParameter;
	pcap_t *adhandle = gpara-&gt;adhandle;
	int res;
	unsigned char Mac[6];
	struct pcap_pkthdr * pkt_header;
	const u_char * pkt_data;
	while (true) {
		if (flag) {
			printf("获取MAC地址完毕,请输入你要发送对方的IP地址:\n");
			break;
		}
		if ((res = pcap_next_ex(adhandle, &amp;pkt_header, &amp;pkt_data)) &gt;= 0) {
			if (*(unsigned short *) (pkt_data + 12) == htons(ETH_ARP)) {
				ArpPacket *recv = (ArpPacket *) pkt_data;
				if (*(unsigned short *) (pkt_data + 20) == htons(ARP_REPLY)) {
					printf("-------------------------------------------\n");
					printf("IP地址:%d.%d.%d.%d   MAC地址:",
						     recv-&gt;ah.SourceIpAdd &amp; 255,
							 recv-&gt;ah.SourceIpAdd &gt;&gt; 8 &amp; 255,
							 recv-&gt;ah.SourceIpAdd &gt;&gt; 16 &amp; 255,
							 recv-&gt;ah.SourceIpAdd &gt;&gt; 24 &amp; 255);
					for (int i = 0; i &lt; 6; i++) {
						Mac[i] = *(unsigned char *) (pkt_data + 22 + i);
						printf("%02x", Mac[i]);
					}
					printf("\n");
				}
			}
		}
		Sleep(10);
	}
	return 0;
}</pre><p>以上暂告一段落，通过整合以上代码，我们可以得到如下运行结果：</p><pre class="crayon-plain-tag">--------------------------------------------------
number:1
name:rpcap://\Device\NPF_{5AC72F8D-019C-4003-B51B-
description:Network adapter 'Microsoft' on local h
        Loopback: no
Address Family Name:AF_INET6
this is an IPV6 address
Address Family Name:AF_INET6
this is an IPV6 address
--------------------------------------------------
number:2
name:rpcap://\Device\NPF_{C17EB3F6-1E86-40E5-8790-
description:Network adapter 'Microsoft' on local h
        Loopback: no
Address Family Name:AF_INET6
this is an IPV6 address
Address Family Name:AF_INET
Address:192.168.95.1
        Netmask: 255.255.255.0
        Broadcast Address: 255.255.255.255
--------------------------------------------------
number:3
name:rpcap://\Device\NPF_{33E23A2F-F791-409B-8452-
description:Network adapter 'Qualcomm Atheros Ar81
oller' on local host
        Loopback: no
Address Family Name:AF_INET6
this is an IPV6 address
Address Family Name:AF_INET6
this is an IPV6 address
Address Family Name:AF_INET6
this is an IPV6 address
Address Family Name:AF_INET
Address:121.250.216.237
        Netmask: 255.255.255.0
        Broadcast Address: 255.255.255.255
--------------------------------------------------
number:4
name:rpcap://\Device\NPF_{DCCF036F-A9A8-4225-B980-
description:Network adapter 'Microsoft' on local h
        Loopback: no
Address Family Name:AF_INET6
this is an IPV6 address
Address Family Name:AF_INET6
this is an IPV6 address
--------------------------------------------------
number:5
name:rpcap://\Device\NPF_{D62A0060-F424-46FC-83A5-
description:Network adapter 'Microsoft' on local h
        Loopback: no
Address Family Name:AF_INET6
this is an IPV6 address
Address Family Name:AF_INET
Address:192.168.191.1
        Netmask: 255.255.255.0
        Broadcast Address: 255.255.255.255
--------------------------------------------------
number:6
name:rpcap://\Device\NPF_{B5224A53-8450-4537-AB3B-
description:Network adapter 'Microsoft' on local h
        Loopback: no
Address Family Name:AF_INET6
this is an IPV6 address
Address Family Name:AF_INET
Address:192.168.191.2
        Netmask: 255.255.255.0
        Broadcast Address: 255.255.255.255
Enter the interface number(1-6):3

ipstr:121.250.216.237
netmask:255.255.255.0

PacketSend succeed
获取自己主机的MAC地址成功!

listening on 网卡2 ...
ip_mac:dc-0e-a1-ec-53-c3
自身的IP地址为:121.250.216.237
地址掩码NETMASK为:255.255.255.0

请按任意键继续. . . ------------------------------
IP地址:121.250.216.1   MAC地址:000fe28e6100
-------------------------------------------
IP地址:121.250.216.3   MAC地址:089e012d20d5
-------------------------------------------
IP地址:121.250.216.5   MAC地址:5404a6af5f2d
-------------------------------------------
IP地址:121.250.216.6   MAC地址:28d244248d81
-------------------------------------------
IP地址:121.250.216.7   MAC地址:80fa5b0283f3
-------------------------------------------
IP地址:121.250.216.8   MAC地址:14dae9005b9e
-------------------------------------------
IP地址:121.250.216.9   MAC地址:b82a72bf8bce
-------------------------------------------
IP地址:121.250.216.12   MAC地址:84c9b2fefeed
-------------------------------------------
IP地址:121.250.216.15   MAC地址:28d2440b4b1b
-------------------------------------------
IP地址:121.250.216.16   MAC地址:bcee7b969beb
-------------------------------------------
........此处省略一万字....</pre><p>接下来我们让用户输入要发送的IP地址和要发送的数据</p><pre class="crayon-plain-tag">u_int ip1,ip2,ip3,ip4;
		scanf_s("%d.%d.%d.%d",&amp;ip1,&amp;ip2,&amp;ip3,&amp;ip4);
		printf("请输入你要发送的内容:\n");
		getchar();
		gets_s(TcpData);
		printf("要发送的内容:%s\n",TcpData);</pre><p>声明一下TcpData</p><pre class="crayon-plain-tag">char TcpData[20];   //发送内容</pre><p>接下来就是重头戏了，需要声明各种结构体，我们发送的是TCP数据，这样，TCP的TcpData 就作为真正的内容，然后在前面加上TCP头，IP头，帧头，还有校验和要正确。</p>
<p>最后构成一个完整的帧，那么另外声明的结构体如下，前面代码声明过的帧头部结构体就去掉了。</p><pre class="crayon-plain-tag">//IP地址格式
struct IpAddress
{
    u_char byte1;
    u_char byte2;
    u_char byte3;
    u_char byte4;
};

//帧头部结构体，共14字节
struct EthernetHeader
{
    u_char DestMAC[6];    //目的MAC地址 6字节
    u_char SourMAC[6];   //源MAC地址 6字节
    u_short EthType;         //上一层协议类型，如0x0800代表上一层是IP协议，0x0806为arp  2字节
};

//IP头部结构体，共20字节
struct IpHeader
{
    unsigned char Version_HLen;   //版本信息4位 ，头长度4位 1字节
    unsigned char TOS;                    //服务类型    1字节
    short Length;                              //数据包长度 2字节
    short Ident;                                 //数据包标识  2字节
    short Flags_Offset;                    //标志3位，片偏移13位  2字节
    unsigned char TTL;                   //存活时间  1字节
    unsigned char Protocol;          //协议类型  1字节
    short Checksum;                       //首部校验和 2字节
	IpAddress SourceAddr;       //源IP地址   4字节
	IpAddress DestinationAddr; //目的IP地址  4字节
};

//TCP头部结构体，共20字节
struct TcpHeader
{
    unsigned short SrcPort;                        //源端口号  2字节
    unsigned short DstPort;                        //目的端口号 2字节
    unsigned int SequenceNum;               //序号  4字节
    unsigned int Acknowledgment;         //确认号  4字节
    unsigned char HdrLen;                         //首部长度4位，保留位6位 共10位
    unsigned char Flags;                              //标志位6位
    unsigned short AdvertisedWindow;  //窗口大小16位 2字节
    unsigned short Checksum;                  //校验和16位   2字节
    unsigned short UrgPtr;						  //紧急指针16位   2字节
};

//TCP伪首部结构体 12字节
struct PsdTcpHeader
{
	IpAddress SourceAddr;                     //源IP地址  4字节
	IpAddress DestinationAddr;             //目的IP地址 4字节
    char Zero;                                                    //填充位  1字节
    char Protcol;                                               //协议号  1字节
    unsigned short TcpLen;                           //TCP包长度 2字节
};</pre><p>继续main函数中对各种结构体的数据进行初始化赋值，并计算校验和。</p><pre class="crayon-plain-tag">//结构体初始化为0序列
		memset(&amp;ethernet, 0, sizeof(ethernet));
		BYTE destmac[8];
		//目的MAC地址,此处没有对帧的MAC地址进行赋值，因为网卡设置的混杂模式，可以接受经过该网卡的所有帧。当然最好的方法是赋值为ARP刚才获取到的MAC地址，当然不赋值也可以捕捉到并解析，在此处仅做下说明。
		destmac[0] = 0x00;
		destmac[1] = 0x11;
		destmac[2] = 0x22;
		destmac[3] = 0x33;
		destmac[4] = 0x44;
		destmac[5] = 0x55;
		//赋值目的MAC地址
		memcpy(ethernet.DestMAC, destmac, 6);
		BYTE hostmac[8];
		//源MAC地址
		hostmac[0] = 0x00;
		hostmac[1] = 0x1a;
		hostmac[2] = 0x4d;
		hostmac[3] = 0x70;
		hostmac[4] = 0xa3;
		hostmac[5] = 0x89;
		//赋值源MAC地址
		memcpy(ethernet.SourMAC, hostmac, 6);
		//上层协议类型,0x0800代表IP协议
		ethernet.EthType = htons(0x0800);
		//赋值SendBuffer
		memcpy(&amp;SendBuffer, ðernet, sizeof(struct EthernetHeader));
		//赋值IP头部信息
		ip.Version_HLen = 0x45;
		ip.TOS = 0;
		ip.Length = htons(sizeof(struct IpHeader) + sizeof(struct TcpHeader) + strlen(TcpData));
		ip.Ident = htons(1);
		ip.Flags_Offset = 0;
		ip.TTL = 128;
		ip.Protocol = 6;
		ip.Checksum = 0;
		//源IP地址
		ip.SourceAddr.byte1 = 127;
		ip.SourceAddr.byte2 = 0;
		ip.SourceAddr.byte3 = 0;
		ip.SourceAddr.byte4 = 1;
		//目的IP地址
		ip.DestinationAddr.byte1 = ip1;
		ip.DestinationAddr.byte2 = ip2;
		ip.DestinationAddr.byte3 = ip3;
		ip.DestinationAddr.byte4 = ip4;
		//赋值SendBuffer
		memcpy(&amp;SendBuffer[sizeof(struct EthernetHeader)], &amp;ip, 20);
		//赋值TCP头部内容
		tcp.DstPort = htons(102);
		tcp.SrcPort = htons(1000);
		tcp.SequenceNum = htonl(11);
		tcp.Acknowledgment = 0;
		tcp.HdrLen = 0x50;
		tcp.Flags = 0x18;
		tcp.AdvertisedWindow = htons(512);
		tcp.UrgPtr = 0;
		tcp.Checksum = 0;
		//赋值SendBuffer
		memcpy(&amp;SendBuffer[sizeof(struct EthernetHeader) + 20], &amp;tcp, 20);
		//赋值伪首部
		ptcp.SourceAddr = ip.SourceAddr;
		ptcp.DestinationAddr = ip.DestinationAddr;
		ptcp.Zero = 0;
		ptcp.Protcol = 6;
		ptcp.TcpLen = htons(sizeof(struct TcpHeader) + strlen(TcpData));
		//声明临时存储变量，用来计算校验和
		char TempBuffer[65535];
		memcpy(TempBuffer, &amp;ptcp, sizeof(struct PsdTcpHeader));
		memcpy(TempBuffer + sizeof(struct PsdTcpHeader), &amp;tcp, sizeof(struct TcpHeader));
		memcpy(TempBuffer + sizeof(struct PsdTcpHeader) + sizeof(struct TcpHeader), TcpData, strlen(TcpData));
		//计算TCP的校验和
		tcp.Checksum = checksum((USHORT*)(TempBuffer), sizeof(struct PsdTcpHeader) + sizeof(struct TcpHeader) + strlen(TcpData));
		//重新把SendBuffer赋值，因为此时校验和已经改变，赋值新的
		memcpy(SendBuffer + sizeof(struct EthernetHeader) + sizeof(struct IpHeader), &amp;tcp, sizeof(struct TcpHeader));
		memcpy(SendBuffer + sizeof(struct EthernetHeader) + sizeof(struct IpHeader) + sizeof(struct TcpHeader), TcpData, strlen(TcpData));
		//初始化TempBuffer为0序列，存储变量来计算IP校验和
		memset(TempBuffer, 0, sizeof(TempBuffer));
		memcpy(TempBuffer, &amp;ip, sizeof(struct IpHeader));
		//计算IP校验和
		ip.Checksum = checksum((USHORT*)(TempBuffer), sizeof(struct IpHeader));
		//重新把SendBuffer赋值，IP校验和已经改变
		memcpy(SendBuffer + sizeof(struct EthernetHeader), &amp;ip, sizeof(struct IpHeader));
		//发送序列的长度
		int size = sizeof(struct EthernetHeader) + sizeof(struct IpHeader) + sizeof(struct TcpHeader) + strlen(TcpData);
		int result = pcap_sendpacket(adhandle, SendBuffer,size);
		if (result != 0)
		{
			printf("Send Error!\n");
		} 
		else
		{
			printf("Send TCP Packet.\n");
			printf("Dstination Port:%d\n", ntohs(tcp.DstPort));
			printf("Source Port:%d\n", ntohs(tcp.SrcPort));
			printf("Sequence:%d\n", ntohl(tcp.SequenceNum));
			printf("Acknowledgment:%d\n", ntohl(tcp.Acknowledgment));
			printf("Header Length:%d*4\n", tcp.HdrLen &gt;&gt; 4);
			printf("Flags:0x%0x\n", tcp.Flags);
			printf("AdvertiseWindow:%d\n", ntohs(tcp.AdvertisedWindow));
			printf("UrgPtr:%d\n", ntohs(tcp.UrgPtr));
			printf("Checksum:%u\n", ntohs(tcp.Checksum));
			printf("Send Successfully!\n");
		}</pre><p>校验和方法如下：</p><pre class="crayon-plain-tag">//获得校验和的方法
unsigned short checksum(unsigned short *data, int length)
{
    unsigned long temp = 0;
    while (length &gt; 1)
    {
        temp +=  *data++;
        length -= sizeof(unsigned short);
    }
    if (length)
    {
        temp += *(unsigned short*)data;
    }
    temp = (temp &gt;&gt; 16) + (temp &amp;0xffff);
    temp += (temp &gt;&gt; 16);
    return (unsigned short)(~temp);
}</pre><p>记得在声明一下这个方法。如果放在main函数前当然就不用声明啦。</p>
<p>另外需要声明的变量有</p><pre class="crayon-plain-tag">struct EthernetHeader ethernet;    //以太网帧头
    struct IpHeader ip;                            //IP头
    struct TcpHeader tcp;                      //TCP头
    struct PsdTcpHeader ptcp;             //TCP伪首部</pre><p></p><pre class="crayon-plain-tag">unsigned char SendBuffer[200];       //发送队列</pre><p>接下来的运行结果：</p><pre class="crayon-plain-tag">获取MAC地址完毕,请输
121.250.216.112
请输入你要发送的内容
what is tcp
要发送的内容:what i
Send TCP Packet.
Dstination Port:102
Source Port:1000
Sequence:11
Acknowledgment:0
Header Length:5*4
Flags:0x18
AdvertiseWindow:512
UrgPtr:0
Checksum:17149
Send Successfully!</pre><p>截图如下：</p>
<p><img src="http://img.blog.csdn.net/20141018211905731?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3FjcmU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></p>
<p>好啦，发送帧到此就告一段落啦！如果有疑问请留言。</p>
<p>帧的接收很简单，直接贴源码如下：</p><pre class="crayon-plain-tag">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pcap.h&gt;


char *iptos(u_long in);       //u_long即为 unsigned long
void packet_handler(u_char *param, const struct pcap_pkthdr *header, const u_char *pkt_data);
//struct tm *ltime;					//和时间处理有关的变量

struct IpAddress
{
    u_char byte1;
    u_char byte2;
    u_char byte3;
    u_char byte4;
};

//帧头部结构体，共14字节
struct EthernetHeader
{
    u_char DestMAC[6];    //目的MAC地址 6字节
    u_char SourMAC[6];   //源MAC地址 6字节
    u_short EthType;         //上一层协议类型，如0x0800代表上一层是IP协议，0x0806为arp  2字节
};

//IP头部结构体，共20字节
struct IpHeader
{
    unsigned char Version_HLen;   //版本信息4位 ，头长度4位 1字节
    unsigned char TOS;                    //服务类型    1字节
    short Length;                              //数据包长度 2字节
    short Ident;                                 //数据包标识  2字节
    short Flags_Offset;                    //标志3位，片偏移13位  2字节
    unsigned char TTL;                    //存活时间  1字节
    unsigned char Protocol;           //协议类型  1字节
    short Checksum;                        //首部校验和 2字节
    IpAddress SourceAddr;           //源IP地址   4字节
    IpAddress DestinationAddr;   //目的IP地址  4字节
};

//TCP头部结构体，共20字节
struct TcpHeader
{
    unsigned short SrcPort;                        //源端口号  2字节
    unsigned short DstPort;                        //目的端口号 2字节
    unsigned int SequenceNum;               //序号  4字节
    unsigned int Acknowledgment;         //确认号  4字节
    unsigned char HdrLen;                         //首部长度4位，保留位6位 共10位
    unsigned char Flags;                              //标志位6位
    unsigned short AdvertisedWindow;  //窗口大小16位 2字节
    unsigned short Checksum;                  //校验和16位   2字节
    unsigned short UrgPtr;						  //紧急指针16位   2字节
};

//TCP伪首部结构体 12字节
struct PsdTcpHeader
{
    unsigned long SourceAddr;                     //源IP地址  4字节
    unsigned long DestinationAddr;             //目的IP地址 4字节
    char Zero;                                                    //填充位  1字节
    char Protcol;                                               //协议号  1字节
    unsigned short TcpLen;                           //TCP包长度 2字节
};


int main(){

	EthernetHeader *ethernet;    //以太网帧头
    IpHeader *ip;                            //IP头
    TcpHeader *tcp;                      //TCP头
    PsdTcpHeader *ptcp;             //TCP伪首部

	pcap_if_t  * alldevs;       //所有网络适配器
	pcap_if_t  *d;					//选中的网络适配器
	char errbuf[PCAP_ERRBUF_SIZE];   //错误缓冲区,大小为256
	char source[PCAP_ERRBUF_SIZE];
	pcap_t *adhandle;           //捕捉实例,是pcap_open返回的对象
	int i = 0;                            //适配器计数变量
	struct pcap_pkthdr *header;    //接收到的数据包的头部
    const u_char *pkt_data;			  //接收到的数据包的内容
	int res;                                    //表示是否接收到了数据包
	u_int netmask;                       //过滤时用的子网掩码
	char packet_filter[] = "tcp";        //过滤字符
	struct bpf_program fcode;                     //pcap_compile所调用的结构体

	u_int ip_len;                                       //ip地址有效长度
	u_short sport,dport;                        //主机字节序列
	u_char packet[100];                       //发送数据包目的地址
	pcap_dumper_t *dumpfile;         //堆文件

	//time_t local_tv_sec;				//和时间处理有关的变量
    //char timestr[16];					//和时间处理有关的变量

	
	//获取本地适配器列表
	if(pcap_findalldevs_ex(PCAP_SRC_IF_STRING,NULL,&amp;alldevs,errbuf) == -1){
		//结果为-1代表出现获取适配器列表失败
		fprintf(stderr,"Error in pcap_findalldevs_ex:\n",errbuf);
		//exit(0)代表正常退出,exit(other)为非正常退出,这个值会传给操作系统
		exit(1);
	}
	//打印设备列表信息
	for(d = alldevs;d !=NULL;d = d-&gt;next){
		printf("-----------------------------------------------------------------\nnumber:%d\nname:%s\n",++i,d-&gt;name);
		if(d-&gt;description){
			//打印适配器的描述信息
			printf("description:%s\n",d-&gt;description);
		}else{
			//适配器不存在描述信息
			printf("description:%s","no description\n");
		}
		//打印本地环回地址
		printf("\tLoopback: %s\n",(d-&gt;flags &amp; PCAP_IF_LOOPBACK)?"yes":"no");
		
		 pcap_addr_t *a;       //网络适配器的地址用来存储变量
		 for(a = d-&gt;addresses;a;a = a-&gt;next){
			 //sa_family代表了地址的类型,是IPV4地址类型还是IPV6地址类型
			 switch (a-&gt;addr-&gt;sa_family)
			 {
				 case AF_INET:  //代表IPV4类型地址
					 printf("Address Family Name:AF_INET\n");
					 if(a-&gt;addr){
						 //-&gt;的优先级等同于括号,高于强制类型转换,因为addr为sockaddr类型，对其进行操作须转换为sockaddr_in类型
						 printf("Address:%s\n",iptos(((struct sockaddr_in *)a-&gt;addr)-&gt;sin_addr.s_addr));
					 }
					if (a-&gt;netmask){
						 printf("\tNetmask: %s\n",iptos(((struct sockaddr_in *)a-&gt;netmask)-&gt;sin_addr.s_addr));
					}
					if (a-&gt;broadaddr){
						   printf("\tBroadcast Address: %s\n",iptos(((struct sockaddr_in *)a-&gt;broadaddr)-&gt;sin_addr.s_addr));
					 }
					 if (a-&gt;dstaddr){
						   printf("\tDestination Address: %s\n",iptos(((struct sockaddr_in *)a-&gt;dstaddr)-&gt;sin_addr.s_addr));
					 }
        			 break;
				 case AF_INET6: //代表IPV6类型地址
					 printf("Address Family Name:AF_INET6\n");
					 printf("this is an IPV6 address\n");
					 break;
				 default:
					 break;
			 }
		 }
	}
	//i为0代表上述循环未进入,即没有找到适配器,可能的原因为Winpcap没有安装导致未扫描到
	if(i == 0){
		printf("interface not found,please check winpcap installation");
	}

	int num;
	printf("Enter the interface number(1-%d):",i);
	//让用户选择选择哪个适配器进行抓包
	scanf_s("%d",&amp;num);
	printf("\n");

	//用户输入的数字超出合理范围
	if(num&lt;1||num&gt;i){
		printf("number out of range\n");
		pcap_freealldevs(alldevs);
		return -1;
	}
	//跳转到选中的适配器
	for(d=alldevs, i=0; i&lt; num-1 ; d=d-&gt;next, i++);

	//运行到此处说明用户的输入是合法的
	if((adhandle = pcap_open(d-&gt;name,		//设备名称
														65535,       //存放数据包的内容长度
														PCAP_OPENFLAG_PROMISCUOUS,  //混杂模式
														1000,           //超时时间
														NULL,          //远程验证
														errbuf         //错误缓冲
														)) == NULL){
        //打开适配器失败,打印错误并释放适配器列表
		fprintf(stderr,"\nUnable to open the adapter. %s is not supported by WinPcap\n", d-&gt;name);
        // 释放设备列表 
        pcap_freealldevs(alldevs);
        return -1;
	}
	

	//打印输出,正在监听中
	printf("\nlistening on %s...\n", d-&gt;description);

	//所在网络不是以太网,此处只取这种情况
	if(pcap_datalink(adhandle) != DLT_EN10MB)
    {
        fprintf(stderr,"\nThis program works only on Ethernet networks.\n");
        //释放列表
        pcap_freealldevs(alldevs);
        return -1;
    }

	//先获得地址的子网掩码
	if(d-&gt;addresses != NULL)
        //获得接口第一个地址的掩码 
        netmask=((struct sockaddr_in *)(d-&gt;addresses-&gt;netmask))-&gt;sin_addr.S_un.S_addr;
    else
        // 如果接口没有地址，那么我们假设一个C类的掩码
        netmask=0xffffff;

	//pcap_compile()的原理是将高层的布尔过滤表
	//达式编译成能够被过滤引擎所解释的低层的字节码
	if(pcap_compile(adhandle,	//适配器处理对象
										&amp;fcode,
										packet_filter,   //过滤ip和UDP
										1,                       //优化标志
										netmask           //子网掩码
										)&lt;0)
	{
		//过滤出现问题
		fprintf(stderr,"\nUnable to compile the packet filter. Check the syntax.\n");
        // 释放设备列表
        pcap_freealldevs(alldevs);
        return -1;
	}

	//设置过滤器
    if (pcap_setfilter(adhandle, &amp;fcode)&lt;0)
    {
        fprintf(stderr,"\nError setting the filter.\n");
        //释放设备列表
        pcap_freealldevs(alldevs);
        return -1;
    }


	//利用pcap_next_ex来接受数据包
	while((res = pcap_next_ex(adhandle,&amp;header,&amp;pkt_data))&gt;=0)
	{
		if(res ==0){
			//返回值为0代表接受数据包超时，重新循环继续接收
			continue;
		}else{
			//运行到此处代表接受到正常从数据包
			//header为帧的头部
			printf("%.6ld len:%d ", header-&gt;ts.tv_usec, header-&gt;len);
			// 获得IP数据包头部的位置
			ip = (IpHeader *) (pkt_data +14);    //14为以太网帧头部长度
			//获得TCP头部的位置
			ip_len = (ip-&gt;Version_HLen &amp; 0xf) *4;
			printf("ip_length:%d ",ip_len);
			tcp = (TcpHeader *)((u_char *)ip+ip_len);
			char * data;
			 data = (char *)((u_char *)tcp+20);
			 //将网络字节序列转换成主机字节序列
			sport = ntohs( tcp-&gt;SrcPort );
			dport = ntohs( tcp-&gt;DstPort );
			printf("srcport:%d desport:%d\n",sport,dport);
			printf("%d.%d.%d.%d.%d -&gt; %d.%d.%d.%d.%d\n",
					ip-&gt;SourceAddr.byte1,
					ip-&gt;SourceAddr.byte2,
					ip-&gt;SourceAddr.byte3,
					ip-&gt;SourceAddr.byte4,
				    sport,
				    ip-&gt;DestinationAddr.byte1,
				    ip-&gt;DestinationAddr.byte2,
				    ip-&gt;DestinationAddr.byte3,
				    ip-&gt;DestinationAddr.byte4,
				    dport);
			printf("%s\n",data);
		}

	}

	
	//释放网络适配器列表
	pcap_freealldevs(alldevs);

	/**
	int pcap_loop  ( pcap_t *  p,  
								  int  cnt,  
								  pcap_handler  callback,  
								  u_char *  user   
								 );
     typedef void (*pcap_handler)(u_char *, const struct pcap_pkthdr *,
                 const u_char *);
	*/
	//开始捕获信息,当捕获到数据包时,会自动调用这个函数
	//pcap_loop(adhandle,0,packet_handler,NULL);

	int inum;
	scanf_s("%d", &amp;inum);

	return 0;

}

/* 每次捕获到数据包时，libpcap都会自动调用这个回调函数 */
/**
pcap_loop()函数是基于回调的原理来进行数据捕获的，如技术文档所说，这是一种精妙的方法，并且在某些场合下，
它是一种很好的选择。但是在处理回调有时候会并不实用，它会增加程序的复杂度，特别是在多线程的C++程序中
*/
/*
void packet_handler(u_char *param, const struct pcap_pkthdr *header, const u_char *pkt_data)
{
    struct tm *ltime = NULL;
    char timestr[16];
    time_t local_tv_sec;

    // 将时间戳转换成可识别的格式
    local_tv_sec = header-&gt;ts.tv_sec;
    localtime_s(ltime,&amp;local_tv_sec);
    strftime( timestr, sizeof timestr, "%H:%M:%S", ltime);

    printf("%s,%.6ld len:%d\n", timestr, header-&gt;ts.tv_usec, header-&gt;len);

}
*/
/* 将数字类型的IP地址转换成字符串类型的 */
#define IPTOSBUFFERS    12
char *iptos(u_long in)
{
    static char output[IPTOSBUFFERS][3*4+3+1];
    static short which;
    u_char *p;

    p = (u_char *)&amp;in;
    which = (which + 1 == IPTOSBUFFERS ? 0 : which + 1);
    sprintf_s(output[which], "%d.%d.%d.%d", p[0], p[1], p[2], p[3]);
    return output[which];
}</pre><p>&nbsp;</p>
<p>运行截图如下</p>
<p><img src="http://img.blog.csdn.net/20141018212813479?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3FjcmU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></p>
<p><img src="http://img.blog.csdn.net/20141018212943896?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3FjcmU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" /></p>
<p>Thank You</p>
<p>如有问题，欢迎留言~</p>
<p>&nbsp;</p>
<p>转载请注明：<a href="http://blog.cuiqingcai.com">静觅</a> &raquo; <a href="http://blog.cuiqingcai.com/1918.html">Winpcap网络编程五之ARP协议获得MAC表及主机通信</a></p>]]></content:encoded>
			<wfw:commentRss>http://blog.cuiqingcai.com/1918.html/feed</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
	</channel>
</rss>

<!-- Dynamic page generated in 1.302 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2015-11-13 18:08:29 -->
